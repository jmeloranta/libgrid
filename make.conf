# Compiler selection (only gcc supported):
# gcc          - GCC optimized
# gcc-debug    - GCC debug
#
COMPILER = gcc
#
# Data types: REAL = float, double or quad (quad = long double). INT = int or long (use long)
#
REAL = double
INT = long
#
# Install root
ROOT = /usr
#
# Use CUDA? (enables ?grid3d_cufft* routines). yes or no.
# If you are on fedora, install cuda-gcc and cuda-gcc-c++. If not, the best bet is to replace cuda-gcc with gcc (gcc 8.x will not work)
# CUDA_TPB = threads per block per dimension (e.g., 8 will yield 8 * 8 * 8 = 512 threads per block)
# CUDA_THRADJ = how to distribute 3-D threads to 2-D (multiplicative factor 2 - 3).
# Fast math only works with single precision (not sure how usable?)
#
CUDA = yes
ifeq ($(CUDA),yes)
CUDA_DEV = 0
CUDAINC = /usr/include/cuda
CUDALIB = /usr/lib64
CUDAHOST_CC = /usr/bin/cuda-gcc
ifndef CUDA_CC
CUDA_CC = $(shell /bin/cat $(ROOT)/include/grid/cuda.arch)
endif
CUDA_FASTMATH = no
CUDA_TPB = 8
CUDA_THRADJ = 3
CUDA_DEBUG = no
endif
#
# Use LAPACK? (used only by couple of diagonalization routines in libgrid; not needed for libdft)
#
USE_LAPACK = yes
#
AR = ar
RANLIB = ranlib
#
CFLAGS = -DHBAR=1.0
NVCFLAGS = -DHBAR=1.0 -arch=$(CUDA_CC) -ccbin $(CUDAHOST_CC) --compiler-options -Wall
LDFLAGS = 

ifeq ($(COMPILER),gcc)
  CC = gcc
  CFLAGS += -std=gnu89 -g -Wall -Wconversion -march=native -mtune=native -Ofast -fopenmp
  LDFLAGS += /usr/lib/libgrid.a -lm -lgomp
endif

ifeq ($(COMPILER),gcc-debug)
  CC = gcc
  CFLAGS += -std=gnu89 -g -Wall -Wconversion
  LDFLAGS += /usr/lib/libgrid.a -lm -lgomp
endif

ifeq ($(USE_LAPACK),yes)
  CFLAGS += -DUSE_LAPACK
  LDFLAGS += -llapack -lblas
endif

ifeq ($(REAL),float)
# -Wdouble-promotion
  DTYPE = -DREAL=float -DSINGLE_PREC -DCREAL=crealf -DCIMAG=cimagf -DCONJ=conjf -DPOW=powf -DSQRT=sqrtf -DCSQRT=csqrtf -DEXP=expf -DCEXP=cexpf -DLOG=logf -DCLOG=clogf -DCOS=cosf -DSIN=sinf -DTAN=tanf -DATAN2=atan2f -DFABS=fabsf -DCABS=cabsf -DACOS=acosf -DASIN=asinf -DATAN=atanf -DTANH=tanhf -DCOSH=coshf -DSINH=sinhf -DCPOW=cpowf
  CFLAGS += -fsingle-precision-constant 
  LDFLAGS += -lfftw3f_omp -lfftw3f
else ifeq ($(REAL),double)
  DTYPE = -DREAL=double -DDOUBLE_PREC -DCREAL=creal -DCIMAG=cimag -DCONJ=conj -DPOW=pow -DSQRT=sqrt -DCSQRT=csqrt -DEXP=exp -DCEXP=cexp -DLOG=log -DCLOG=clog -DCOS=cos -DSIN=sin -DTAN=tan -DATAN2=atan2 -DFABS=fabs -DCABS=cabs -DACOS=acos -DASIN=asin -DATAN=atan -DTANH=tanh -DCOSH=cosh -DSINH=sinh -DCPOW=cpow
  CFLAGS += -malign-double
  LDFLAGS += -lfftw3_omp -lfftw3
else ifeq ($(REAL),quad)
  ifeq (CUDA,yes)
    echo "Quad precision not supported with CUFFT."
    exit 1
  endif
  DTYPE = -DREAL="long double" -DQUAD_PREC -DCREAL=creall -DCIMAG=cimagl -DCONJ=conjl -DPOW=powl -DSQRT=sqrtl -DCSQRT=csqrtl -DEXP=expl -DCEXP=cexpl -DLOG=logl -DCLOG=clogl -DCOS=cosl -DSIN=sinl -DTAN=tanl -DATAN2=atan2l -DFABS=fabsl -DCABS=cabsl -DACOS=acosl -DASIN=asinl -DATAN=atanl -DTANH=tanhl -DCOSH=coshl -DSINH=sinhl -DCPOW=cpowl
  LDFLAGS += -lfftw3l_omp -lfftw3l
else
  echo "Unknown floating point precision."
  exit 1
endif

ifeq ($(INT),int)
  DTYPE += -DINT=int -DSHORT_INT -DABS=abs
else
  DTYPE += -DINT=long -DLONG_INT -DABS=labs
endif
CFLAGS += $(DTYPE)

ifeq ($(CUDA),yes)
  CFLAGS += -I$(CUDAINC) -DUSE_CUDA -DCUDA_DEVICE=$(CUDA_DEV) -DCUDA_THREADS_PER_BLOCK=$(CUDA_TPB) -DCUDA_CN_THRADJ=$(CUDA_THRADJ) -Wall -DHBAR=1.0
  ifeq ($(CUDA_DEBUG),yes)
    CFLAGS += -DCUDA_DEBUG
  endif
  ifeq ($(COMPILER),gcc-debug)
    NVCFLAGS += -I/usr/include/cuda -g $(DTYPE) --DCUDA_THREADS_PER_BLOCK=$(CUDA_TPB) -DCUDA_CN_THRADJ=$(CUDA_THRADJ)
  else
#    NVCFLAGS += -I/usr/include/cuda -Xptxas -O3 -Xcompiler -O3 $(DTYPE) -DCUDA_THREADS_PER_BLOCK=$(CUDA_TPB) -DCUDA_CN_THRADJ=$(CUDA_THRADJ)
    NVCFLAGS += -I/usr/include/cuda $(DTYPE) -DCUDA_THREADS_PER_BLOCK=$(CUDA_TPB) -DCUDA_CN_THRADJ=$(CUDA_THRADJ)
  endif
  ifeq ($(CUDA_FASTMATH),yes)
    NVCFLAGS += --ftz=true --prec-div=false --prec-sqrt=false --fmad=true
  else
    NVCFLAGS += --ftz=false --prec-div=true --prec-sqrt=true --fmad=true
  endif
  LDFLAGS += -L$(CUDALIB) -lcufft -lcuda -lcudart -lstdc++
endif
