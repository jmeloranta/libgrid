\documentclass[12pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Jussi Eloranta}
\title{libgrid manual}
\begin{document}

\section{Introduction}

Libgrid provides routines for efficiently accessing and manipulating 1-D, 2-D, and 3-D Cartesian real and complex grids on Linux-based systems without the need of considering the underlying specialized hardware (e.g., OpenMP, CUDA). In addition to the basic grid operations such as grid allocation, release, Fourier transform, grid arithmetics, etc., it has also specialized routines for propagating time-dependent Schr\"odinger equation in real or imaginary time. The latter routines are required by libdft library, which solves various types of non-linear Schr\"odinger equations that describe superfluid $^4$He and Bose-Einstein condensates. Libgrid was written by Lauri Lehtovaara, David Mateo, and Jussi Eloranta, and is freely distributed according to GNU GENERAL PUBLIC LICENSE Version 3 (see doc/GPL.txt).

\section{Installation}

Installation of libgrid requires the following packages:
\begin{itemize}
\item git (a free and open source distributed version control system)
\item GNU C compiler with OpenMP support (gcc)
\item FFTW 3.x (Fast Fourier Transform package)
\item LAPACK (Linear Algebra PACKage; optional)
\item BLAS (Basic Linear Algebra Subprograms; optional)
\end{itemize}
To install these packages on Fedora linux, use (\# implies execution with root privileges): 
\begin{verbatim}
# dnf install git gcc fftw-* lapack lapack-devel blas blas-devel
\end{verbatim}
If the system has NVIDIA GPUs, libgrid can use CUDA to accelerate the grid operations. For Fedora-based systems, the propriatary NVIDIA drivers and the CUDA libraries can be obtained from: \url{https://negativo17.org/nvidia-driver/}. This installation is compatible with the default settings in make.conf as described below. Currently, libgrid does not support OpenCL.

To copy the current version of libgrid to subdirectory libgrid, issue (\% implies execution with normal user privileges):
\begin{verbatim}
% git clone https://github.com/jmeloranta/libgrid.git
\end{verbatim}
Change to libgrid directory and review the configuration settings:
\begin{verbatim}
% cd libgrid
% more make.conf
\end{verbatim}
The options specified in this file determine how libgrid will be compiled. OpenMP support is included automatically with COMPILER = gcc.\\

\begin{tabular}{ll}
\textbf{Option} & \textbf{Description}\\
\cline{1-2}
COMPILER & gcc (normal use) or gcc-debug (non-parallel debugging version)\\
REAL & Real floating point precision (float, double or quad precision).\\
     & Note that for libdft use, single precision floats have limited use.\\
INT & Integer number size (int or long)\\
ROOT & Root installation directory (default /usr)\\
CUDA & Set to "yes" if CUDA is installed and "no" if not. The default\\
     & is to auto-detect.\\
CUDA\_DEV & Which CUDA device number to use by default (0 = first GPU).\\
          & Note: GPU device number can be changed in the user code.\\
CUDAINC & Include file directory for CUDA C header files (default\\
        & /usr/include/cuda).\\
CUDALIB & Directory containing the CUDA libraries (default /usr/lib64).\\
CUDA\_HOSTCC & GCC version that is compatible with the current installation of\\
             & CUDA (default /usr/bin/cuda-gcc).\\
CUDA\_CC & NVIDIA GPU architecture (e.g., sm\_50; default auto-detect).\\
CUDA\_FASTMATH & "yes" implies NVCC options: --ftz=true --prec-div=false\\
               & --prec-sqrt=false --fmad=true and "no" implies options:\\
               & --ftz=false --prec-div=true --prec-sqrt=true --fmad=true\\
               & (default no).\\
CUDA\_TPB & Number of CUDA threads per block (GPU architecture\\
          & dependent; default 6).\\
CUDA\_THRADJ & CUDA Thread adjustment for 2-D operations (i.e., Crank\\
             & -Nicolson). GPU architecture dependent value, 2 - 3\\
             & (default 3).\\
CUDA\_DEBUG & Whether to include debug code in libggrid CUDA routines\\
            & ("yes" or "no"; default no).\\
USE\_LAPACK & Some routines in libgrid use LAPACK (not needed for libdft).\\
            & Use "yes" to include them or "no" to leave them out.\\
AR & Archive program (default ar).\\
\end{tabular}
To compile the library, change to src subdirectory and issue make:
\begin{verbatim}
% cd src
% make -j
\end{verbatim}
Provided that the compilation completed without errors, install the library (as root):
\begin{verbatim}
# make install
\end{verbatim}

\section{Accessing the library routines}

To access libgrid functions in C program, the following header files should be included:
\begin{verbatim}
#include <grid/grid.h>
#include <grid/au.h>
\end{verbatim}
where the first include file is required and the second optional include makes the following conversion factors available:\\

\begin{tabular}{ll}
GRID\_AUTOANG & Factor to convert from Bohr to \AA{}nstr\"om ($10^{-10}$ m).\\
GRID\_AUTOM & Factor to convert from Bohr to meter.\\
GRID\_AUTOK & Factor to convert from Hartee to Kelvin (energy; $kT$).\\
GRID\_AUTOCM1 & Factor to convert from Hartree to wavenumber.\\
GRID\_HZTOCM1 & Factor to convert from Hz to wavenumber.\\
GRID\_AUTOAMU & Atomic unit mass (electron mass) to atomic mass\\
              & unit (AMU).\\
GRID\_AUTOFS & Atomic unit time to femtosecond.\\
GRID\_AUTOS  & Atomic unit time to second.\\
GRID\_AUTOBAR & Atomic pressure unit (Hartree/Bohr$^2$) to bar.\\
GRID\_AUTOPA & Atomic pressure unit to Pa (Pascal).\\
GRID\_AUTOATM & Atomic pressure unit to atm.\\
GRID\_AUTOMPS & Atomic velocity unit to m/s.\\
GRID\_AUTON & Atomic force unit to Newton (N).\\
GRID\_AUTOVPM & Atomic electric field strength to V/m.\\
GRID\_AUTOPAS & Atomic viscosity unit to Pa s.\\
GRID\_AUKB & Boltzmann constant in a.u. ($k_B$)\\ 
\end{tabular}\\

\noindent
Note that wherever applicable, librid will use the atomic unit system and the above conversion factors are provided for converting to other systems. To convert from atomic unit to another unit, multiply by the predefined factor above or, divide by it in order to convert the other way around.

To compile and link a program using libgrid, it is most convenient to construct a makefile (note that the \$(CC) line has TAB as the first character):
\begin{verbatim}
include /usr/include/grid/make.conf

test: test.o
    $(CC) $(CFLAGS) -o test test.o $(LDFLAGS)

test.o: test.c
\end{verbatim}
This will compile the program specified in test.c and link the appropriate libraries automatically. Both CFLAGS and LDFLAGS are obtained automatically from libgrid's make.conf. 

\section{Data types}

The libgrid header file defines the real and integer data types automatically according to those requested during the configuration step (make.conf). Instead of using float, double, int, long etc. directly, use REAL to represent a floating point number and INT to introduce the variables (e.g., REAL x, y; INT i;). To define complex number type, use REAL complex. Since the function names in the system math library vary depending on the floating point precision (e.g., expf(), exp(), expl()), libgrid defines the corresponding function in upper case such that is assigned to the function of the requested precision (e.g., EXP()). So, in order to call the exponential function, use, e.g., y = EXP(x);. Another place where the size of the REAL and INT data types are required is the scanf/printf standard I/O library routines. To print a REAL number with printf, use, for example, printf("value = " FMT\_R "$\backslash$n");. Or to print an INT use FMT\_I.

Libgrid has built-in data types for 1-D, 2-D, and 3-D Cartesian REAL ("rgrid") and REAL complex ("cgrid") grids. To allocate such grids in a C program, first introduce them as pointers, e.g., rgrid *abc or cgrid *abc. Then use either rgrid\_alloc() or cgrid\_alloc() functions to allocate the space. For example:
\begin{verbatim}
   cgrid *abc;
   abc = cgrid_alloc(32, 32, 32, 1.0, CGRID3D_PERIODIC_BOUNDARY, NULL);
   ...
   cgrid_free(abc);
\end{verbatim}
would allocate a periodic 3-D grid with dimensions 32x32x32 and spatial grid step length of 1.0 (for more information on the arguments to cgrid\_alloc() in Section 5). To get a 1-D grid, include it as the last dimension, e.g., 1x1x32, or for a 2-D grid use the two last dimensions, 1x32x32. It is important to follow this convention for performance reasons. In the code, coordinate $x$ corresponds to the first index, $y$ to the second, and $z$ to the third. By default, the origin is placed to the center of the grid.

The basic properties of the above rgrid and cgrid data types are explained below.

\subsection{Real grid data type (rgrid)}

Data type rgrid corresponds to a structure with the following members:
\begin{longtable}{p{.4\textwidth} p{.6\textwidth}}
Member & Description\\
\cline{1-2}
REAL *value & Array holding the real grid point data.\\
char id$[32]$ & String describing the grid (comment).\\
size\_t grid\_len & Number of bytes allocated for value array.\\
INT nx & Number of grid points along the 1st grid index ($x$).\\
INT ny & Number of grid points along the 2nd grid index ($y$).\\
INT nz & Number of grid points along the 3rd grid index ($z$).\\
INT nz2 & This is equal to $2\times(nz / 2 + 1)$. Used for indexing *value.\\
REAL step & Grid step length (equal in all directions).\\
REAL x0 & Grid origin $x_0$ (default 0.0).\\
REAL y0 & Grid origin $y_0$ (default 0.0).\\
REAL z0 & Grid origin $z_0$ (default 0.0).\\
REAL kx0 & Grid origin $k_{x,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL ky0 & Grid origin $k_{y,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL kz0 & Grid origin $k_{z,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL (*value\_outside) & Pointer to function returning values outside\\
\phantom{X}(rgrid *, INT, INT, INT) & the grid.\\
void *outside\_params\_ptr & Pointer for passing additional data to value\_outside function.\\
REAL default\_outside\_params & Default REAL value for outside\_params\_ptr.\\
fftwX\_plan plan & FFTW plan for forward FFT transforming the grid (X = f, empty, l).\\
fftwX\_plan iplan & FFTW plan for inverse FFT transforming the grid (X = f, empty, l).\\
cufftHandle cufft\_handle\_r2c & CUFFT handle for forward FFT transform (CUDA).\\
cufftHandle cufft\_handle\_c2r & CUFFT handle for inverse FFT transform (CUDA).\\
REAL fft\_norm & Normalization factor for FFT (without including the step length).\\
REAL fft\_norm2 & Normalization factor for FFT (including the step length).\\
\end{longtable}

\noindent
Note that rgrid is the same as struct rgrid\_struct type. To reference the value at index (i, j, k) in grid-$>$value, use:
\begin{verbatim}
grid->value[(i * grid->ny + j) * grid->nz2 + k]
\end{verbatim}
The same indexing applies to 1-D (i = j = 0) and 2-D grids with (i = 0). This does not account for the grid boundary condition. Library function rgrid\_value\_at\_index(rgrid *grid, INT i, INT j, INT k) can be used to retrieve the value subject to the chosen boundary condition automatically. To set value for a grid point at (i, j, k), library function rgrid\_value\_to\_index(rgrid *grid, INT i, INT j, INT k, REAL value) can be used. This function does not consider the boundary condition assigned to the grid. Note that a different indexing scheme must be used if the grid is in the reciprocal (Fourier) space:
\begin{verbatim}
grid->value[(i * grid->ny + j) * (grid->nz / 2 + 1) + k]
\end{verbatim}
Alternatively, function rgrid\_cvalue\_at\_index(rgrid *grid, INT i, INT j, INT k) can be used.

\subsection{Complex grid data type (cgrid)}

Data type cgrid corresponds to a structure with the following members:
\begin{longtable}{p{.55\textwidth} p{.45\textwidth}}
Member & Description\\
\cline{1-2}
REAL complex *value & Array holding the complex grid point data.\\
char id[32] & String describing the grid (comment).\\ 
size\_t grid\_len; & Number of bytes allocated for the value array.\\
INT nx & Number of grid points along the 1st grid index ($x$).\\
INT ny & Number of grid points along the 2nd grid index ($y$).\\
INT nz & Number of grid points along the 3rd grid index ($z$).\\
REAL step & Grid step length (equal in all directions).\\
REAL x0 & Grid origin $x_0$ (default 0.0).\\
REAL y0 & Grid origin $y_0$ (default 0.0).\\
REAL z0 & Grid origin $z_0$ (default 0.0).\\
REAL kx0 & Grid origin $k_{x,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL ky0 & Grid origin $k_{y,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL kz0 & Grid origin $k_{z,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL omega & Rotation frequency around $z$-axis (rotating flow).\\
REAL complex (*value\_outside) & Pointer to function returning values outside\\
\phantom{X}(cgrid *grid, INT, INT, INT) & the grid.\\
void *outside\_params\_ptr & Pointer for passing additional data to value\_outside function.\\
REAL complex default\_outside\_params & Default REAL complex value for outside\_params\_ptr.\\
fftwX\_plan plan & FFTW plan for forward FFT transforming the grid (X = f, empty, l).\\
fftwX\_plan iplan & FFTW plan for inverse FFT transforming the grid (X = f, empty, l).\\
fftwX\_plan implan & Like plan but for non-periodic boundaries (untested).\\
fftwX\_plan iimplan & Like iplan but for non-periodic boundaries (untested).\\
cufftHandle cufft\_handle & CUFFT handle for FFT transforms using CUDA.\\
REAL fft\_norm & Normalization factor for FFT (without including the step length).\\
REAL fft\_norm2 & Normalization factor for FFT (including the step length).\\
\end{longtable}
\noindent
Indexing of the grid values follow the same convention as for rgrid data type.

\subsection{Wave function data type (wf)}

Wave functions are special objects that contain a complex grid (wave function values) and all other necessary parameters such that it can be propagated in time by using a non-linear Schr\"odinger equation. This data type is mostly used in libdft library.

\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Member & Description\\
\cline{1-2}
cgrid *grid & Complex grid containing the wave function values.\\
REAL mass & Particle mass that is represented by this wave function.\\
REAL norm & Requested normalization of the wave function.\\
char boundary & Boundary condition to be used for time propagation. WF\_DIRICHLET\_BOUNDARY = Dirichlet boundary condition, WF\_NEUMANN\_BOUNDARY = Neumann boundary condition, WF\_PERIODIC\_BOUNDARY = Periodic boundary condition.\\
char propagator & Time propagator. WF\_2ND\_ORDER\_PROPAGATOR = 2nd order in time, WF\_4TH\_ORDER\_PROPAGATOR = 4th order in time.\\
\end{longtable}

\section{Library functions}

Functions in libgrid are divided into following classes: 1) rgrid\_* (real valued grids; rgrid), 2) cgrid\_* (complex valued grids; cgrid), and 3) grid\_wf\_* (grids describing a wavefunction; wf). These are described in the subsections below. The arguments are listed in the tables in the same order as they are passed to the corresponding functions.

\subsection{Real grid routines}

\subsubsection{rgrid\_alloc() -- Allocate a real-valued grid}

This function allocates memory for a real-valued grid. It takes the following arguments:
\begin{longtable}{p{.4\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
INT nx & Number of points on the grid along $x$ (1st index).\\
INT ny & Number of points on the grid along $y$ (2nd index).\\
INT nz & Number of points on the grid along $z$ (3rd index).\\
REAL step & Spatial step length for the grid.\\
REAL *(value\_outside)() & Function for accessing boundary points: RGRID\_DIRICHLET\_BOUNDARY = Dirichlet boundary, RGRID\_NEUMANN\_BOUNDARY = Neumann boundary, RGRID\_PERIODIC\_BOUNDARY  = Periodic boundary. This can also be a user supplied function.\\
void *outside\_params\_ptr & Pointer for passing parameters for the given boundary access function. Use NULL to with the predefined boundary functions.\\
char *id & String ID describing the grid.
\end{longtable}
\noindent
The return value is a pointer to the allocated grid (rgrid *) or NULL on allocation error. \textit{Note that the grid is kept in padded form, which can be directly used for in-place FFT.}

\subsubsection{rgrid\_set\_origin() -- Set grid origin}

This function sets the origin (i.e., coordinates for the center of the grid). t takes the following arguments:
\begin{longtable}{p{.4\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the origin is to be defined.\\
REAL x0 & $x$ coordinate for the origin.\\
REAL y0 & $y$ coordinate for the origin.\\
REAL z0 & $z$ coordinate for the origin.\\
\end{longtable}
\noindent
This function does not return any value. The mapping between grid indices and coordinates is given by:
\begin{verbatim}
x(i)  = (i - nx / 2) * step - x0
y(j)  = (j - ny / 2) * step - y0
z(k)  = (k - nz / 2) * step - z0
\end{verbatim}
for a grid with dimensions nx$\times$ny$\times$nz, spatial step length step, and origin set at (x0,y0,z0).

\subsubsection{rgrid\_shift\_origin() -- Shift grid origin}

This function shifts the current origin by given offsets. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the origin is to be defined.\\
REAL x0 & Shift in $x$ coordinate (i.e., add x0 to origin $x$).\\
REAL y0 & Shift in $y$ coordinate (i.e., add y0 to origin $y$).\\
REAL z0 & Shift in $z$ coordinate (i.e., add z0 to origin $z$).\\
\end{longtable}
\noindent
This function does not return any value.

\subsubsection{rgrid\_set\_momentum() -- Set grid origin in reciprocal space}

This function sets the grid origin in momentum space (or the velocity of the frame of reference). It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the momentum origin is to be defined.\\
REAL kx0 & Momentum origin along the $x$ axis.\\
REAL ky0 & Momentum origin along the $y$ axis.\\
REAL kz0 & Momentum origin along the $z$ axis.\\
\end{longtable}
\noindent
Here kx0, ky0 and kz0 can be any real numbers but keep in mind that the grid will only contain the component $k = 0$ if they are multiples of:
\begin{verbatim} 
kx0min = 2 * M_PI / (NX * STEP)
ky0min = 2 * M_PI / (NY * STEP)
kz0min = 2 * M_PI / (NZ * STEP)
\end{verbatim}
\noindent
where (NX, NY, NZ) specify the grid dimensions and STEP is the grid spatial step length. In terms of velocities, this means that velocities must be multiples of:
\begin{verbatim} 
kx0min = 2 * M_PI * HBAR / (NX * STEP * MASS)
ky0min = 2 * M_PI * HBAR / (NY * STEP * MASS)
kz0min = 2 * M_PI * HBAR / (NZ * STEP * MASS)
\end{verbatim}
where MASS is the particle mass, and HBAR is $\hbar$. This function does not return any value.

\subsubsection{rgrid\_free() -- Free real-valued grid}

This function takes a pointer to the grid (rgrid *) to be freed as the argument. It has not return value. Note that all allocated memory is automatically released when the program terminates.

\subsubsection{rgrid\_write() -- Write grid on disk in binary format}

This function will write the contents of a given grid to the disk. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be written to disk.\\
FILE *out & File handle for the file I/O.\\
\end{longtable}
\noindent
This is a binary format file where the data is stored in the following order:
\begin{verbatim}
nx
ny
nz
step
(nx * ny * nz2) number of grid point values
\end{verbatim}
where the grid dimensions are (nx,ny,nz) and nz2 = 2 * (nz / 2 + 1). Note that nz2 must be used as we store the grid in padded format. This function does not return any value.

\subsubsection{rgrid\_read() -- Read grid from disk in binary format}

This function will read grid data from disk. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid where the data is to be read. If NULL, a grid with the correct dimensions will be allocated. Note that the boundary condition will assigned to periodic by default.\\
FILE *in & File handle for reading the file I/O.\\
\end{longtable}
This function returns a pointer to the grid or NULL pointer on error.

\subsubsection{rgrid\_copy() -- Copy grid}

Copy a grid to another where the source and destination grids are determined by the arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *copy & Destination grid.\\
rgrid *grid & Source grid.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_shift() -- Shift grid}

This function shifts a grid spatially by a given amount. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *shifted & Destination grid for the operation.\\
rgrid *grid & Source grid for the operation.\\
REAL xs & Shift grid spatially by this amount along $x$.\\
REAL ys & Shift grid spatially by this amount along $y$.\\
REAL zs & Shift grid spatially by this amount along $z$.\\
\end{longtable}
\noindent
The new positions for the grid are:
\begin{verbatim}
x(new) = x - xs 
y(new) = y - ys 
z(new) = z - zs
\end{verbatim}
\noindent
So, the the point (xs, ys, zs) moves to the center of the grid. This function does not return any value.

\subsubsection{rgrid\_zero() - Zero grid values}

This function sets all values in a given grid to zero. The only argument it takes is a pointer (rgrid *) to the grid to be zeroed. It returns no value.

\subsubsection{rgrid\_constant -- Set grid to constant value}

This function is similar to rgrid\_zero() but it allows for an additional argument to specify the value that will be written to the grid. The arguments are as follows:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be set to a constant value.\\
REAL c & Constant value.
\end{longtable}
\noindent
This function does not return any value.

\subsubsection{rgrid\_product\_func() -- Multiply grid by function}

This function multiples a given grid by the values returned by a user specified function. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & Function providing the multiplication values. See below for the arguments to this function.\\
void *farg & Pointer to user specified data that is passed to (*func).\\   
\end{longtable}
\noindent
Function REAL (*func)() takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to user data (provided by *farg above).\\
REAL val & Value at the current grid point.\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
rgrid\_product\_func() function has no return value.

\subsubsection{rgrid\_map -- Map function on grid}

This function maps a user specified function onto a given grid. It takes the following arguments:
Function REAL (*func)() takes the following arguments:\\
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & User specified function providing the mapping. For description of the arguments, see below.\\
void *farg & Pointer to user specified data for (*func)().\\
\end{longtable}
User specified function REAL (*func)() takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to user data (provided by *farg above).\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
rgrid\_map function has no return value.

\subsubsection{rgrid\_smooth\_map -- Smooth map function onto grid}

This function is like rgrid\_map() but performs linear smoothing on the function. This can be used to weight the values at grid points to produce more accurate integration over the grid. This function takes the following arguments:
\begin{longtable}{p{.15\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & Function providing the mapping. The arguments are same as for rgrid\_map() function.\\
void *farg & Pointer to user specified data.\\
INT ns & Number of intermediate points to be used in smoothing.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_adaptive\_map() -- Adaptive smooth map function onto grid}

This function is like rgrid\_smooth\_map() but limits for intermediate steps and requested tolerance can be specified. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & Function providing the mapping. It takes the same arguments as rgrid\_map().\\
void *farg & Pointer to user specified data for (*func)().\\
INT min\_ns & Minimum number of intermediate points to be used in smoothing.\\
INT max\_ns & Maximum number of intermediate points to be used in smoothing.\\
REAL tol & Tolerance for the converge of integral over the function (REAL; input).\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_sum() -- Add two grids}

This function adds two grids and stores the output in a third grid (``gridc = grida + gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the summation.\\
rgrid *gridb & 2nd grid for the summation.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_difference() -- Subtract two grids}

This function subtracts two grids and stores the output in a third grid (``gridc = grida - gridb"). It takes the grid pointers as arguments :
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the difference.\\
rgrid *gridb & 2nd grid for the difference.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_product() -- Product of two grids}

This function takes a product of two grids and stores the output in a third grid (``gridc = grida * gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the product.\\
rgrid *gridb & 2nd grid for the product.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_power() -- Rise grid to power}

This function rises a grid to specified power and stores the output in a third grid (``gridb = grida$^\textnormal{exponent}$"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridb & Destination grid.\\
rgrid *grida & Source grid.\\
REAL exponent & Exponent for power operation.\\
\end{longtable}
\noindent
This function has no return value. Note this function uses math library routine POW().

\subsubsection{rgrid\_abs\_power() -- Rise absolute grid to power}

This function rises absolute value of a grid to specified power and stores the output in a third grid (``gridb = $|$grida$|^\textnormal{exponent}$"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridb & Destination grid.\\
rgrid *grida & Source grid.\\
REAL exponent & Exponent for power operation.\\
\end{longtable}
\noindent
This function has no return value. Note this function uses math library routine POW().

\subsubsection{rgrid\_division() -- Divide two grids}

This function divides two grids and stores the output in a third grid (``gridc = grida / gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the division.\\
rgrid *gridb & 2nd grid for the division.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_division\_eps() -- Safe divide two grids}

This function ``safely" divides two grids and stores the output in a third grid (``gridc = grida / (gridb + eps)"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the division.\\
rgrid *gridb & 2nd grid for the division.\\
REAL eps & Small number to be added to the denominator.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_add() - Add constant to grid}

This function adds a constant number to a grid (``grid = grid + c"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid where the constant is added.\\
REAL c & Number to be added.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_multiply() -- Multiply grid by constant}

This function multiplied a grid by constant (``grid = grid * c"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied.\\
REAL c & Number to multiply with.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_add\_and\_multiply() -- Add and multiply grid}

This function adds a constant to grid and multiplies it with another constant (``grid = (grid + ca) * cm"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied.\\
REAL ca & Constant to be added to the grid.\\
REAL cm & Constant to be multiplied with the grid.\\
\end{longtable}
\noindent
This function has no return value. Note that the adding and multiplying are done in different order as in rgrid\_multiply\_and\_add().

\subsubsection{rgrid\_multiply\_and\_add() -- Multiply and add grid}

This function adds a constant to grid and multiplies it with another constant (``grid = cm * grid + ca"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied.\\
REAL cm & Constant to be multiplied with the grid.\\
REAL ca & Constant to be added to the grid.\\
\end{longtable}
\noindent
This function has no return value. Note that the adding and multiplying are done in different order as in rgrid\_add\_and\_multiply().

\subsubsection{rgrid\_add\_scaled() -- Add scaled grids}

This function adds two grids such that the second grid is scaled (``gridc = gridc + d * grida"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Source/destination grid for the operation.\\
REAL d & Multiplier for grida.\\
rgrid *grida & Source grid for the operation.\\
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_add\_scaled\_product() -- Add scaled product of grids}

This function performs operation: ``gridc = gridc + d * grida * gridb". It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Source/destination grid.\\
REAL d & Constant multiplier.\\
rgrid *grida & 2nd source grid.\\
rgrid *gridb & 3rd source grid.\\      
\end{longtable}
\noindent
This function has no return value.

\subsubsection{rgrid\_operate\_one() -- Operate on grid}

Operate on a grid by a given operator: gridc = O(grida). It takes the following arguments:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & Source grid.\\
REAL (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
\end{longtable}
\noindent
The user specified operator (*operator)() maps the value at a grid point to another real number. The arguments to this function pointer are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & Source grid.\\
REAL (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
void *params & Parameters for operator (pointer).\\
\end{longtable}
\noindent
The arguments to (*operator)() are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL val & Value at the current grid point.\\
void *params & Pointer to use supplied parameters.\\
\end{longtable}
\noindent
rgrid\_operate\_one() function has no return value.

\subsubsection{rgrid\_operate\_one\_product() -- Operate and multiply grids}

This function  operates on a grid by a given operator and then multiplies by another grid: ``gridc = gridb * O(grida)". The arguments to this function are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *gridb & Multiply by this grid.\\
rgrid *grida & Multiply by O(grida).\\
REAL (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL val & Value at the current grid point.\\
void *params & Pointer to use supplied parameters.\\
\end{longtable}
\noindent
rgrid\_operate\_one() function has no return value.

\subsubsection{rgrid\_operate\_two() -- Operate on two grids}

This function  operates on a grid by a given operator that depends on two grids: ``gridc = O(grida, gridb)". The arguments to this function are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st source grid for operator.\\
rgrid *gridb & 2nd source grid for operator.\\
REAL (*operator)() & Function operating on grida and gridb. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL aval & Value at the current grid point (grida).\\
REAL bval & Value at the current grid point (gridb).\\
\end{longtable}
\noindent
rgrid\_operate\_two() function has no return value.

\subsubsection{rgrid\_transform\_one() -- Transform grid}

This function operates directly on a grid by a given operator:  "O(grid)". The arguments to this function are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Source/destination grid.\\
void (*operator)() & Function operating on grid. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *val & Value at the current grid points (note: pointer).\\
\end{longtable}
\noindent
rgrid\_transform\_one() function has no return value.

\subsubsection{rgrid\_transform\_two() -- Transform two grids}

This function operates directly on two grids by a given operator: "O(grida,gridb)". The arguments to this function are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid to be operated.\\
rgrid *gridb & 2nd grid to be operated.\\
void *(operator) & Operator for grid and gridb. The arguments to this function are given below.\\
\end{longtable}
\noindent
The arguments to (*operator)() are:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *avalue & Pointer to current grida value.\\
REAL *bvalue & Pointer to current gridb value.\\
\end{longtable}
\noindent
rgrid\_transform\_two() function has no return value.

\subsubsection{rgrid\_integral() -- Integrate over grid}

This function integrates over the given grid. It takes the grid pointer (rgrid *) as the only argument and returns the value of the integral. 

\subsubsection{rgrid\_integral\_region() -- Integrate over grid region}

This function integrates over the given grid region. It takes the following arguments:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be integrated.\\
REAL xl & Lower limit for $x$.\\
REAL xu & Upper limit for $x$.\\
REAL yl & Lower limit for $y$.\\
REAL yu & Upper limit for $y$.\\
REAL zl & Lower limit for $z$.\\
REAL zu & Upper limit for $z$.\\
\end{longtable}
\noindent
This function returns the value of the integral. 

\subsubsection{rgrid\_integral\_of\_square() -- Integrate grid squared}

This function integrates over the given grid squared (``grid$^2$"). It takes the grid pointer (rgrid *) as the only argument and returns the value of the integral.

\subsubsection{rgrid\_integral\_of\_product() -- Overlap between grids}

Calculate the overlap between two grids (i.e., integral over the product of the grids). This function takes the following arguments:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid for integration.\\
rgrid *gridb & 2nd grid for integration.\\
\end{longtable}
\noindent
This function returns the value of the overlap integral (REAL).

\subsubsection{rgrid\_grid\_expectation\_value() -- Grid expectation value}

Calculate the expectation value of a grid over a given probability density: integral(gridb * $|$grida$|^2$). This function takes the following arguments:
\begin{longtable}{p{.35\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid for integration ($|$grida$|^2$).\\
rgrid *gridb & 2nd grid for integration.\\
\end{longtable}
\noindent
This function returns the value of the overlap integral (REAL).

\subsection{Complex grid routines}

\subsection{Mixed real - complex grid routines}

\subsection{Wave function routines}

\subsection{Linear algebra routines}

\section{External functions}

\section{Utilities}

\section{Examples}

\section{References}

\end{document}