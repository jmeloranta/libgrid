\documentclass[12pt,letterpaper]{report}
\usepackage[letterpaper,hcentering,vcentering,left=1in,top=2.45cm,right=1in,bott
om=2.45cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Jussi Eloranta}
\title{libgrid manual}
\begin{document}

\maketitle

\chapter{Prerequisites}

\section{Introduction}

Libgrid provides routines for efficiently accessing and manipulating 1-D, 2-D, and 3-D Cartesian real and complex grids on Linux-based systems without the need of considering the underlying specialized hardware (e.g., OpenMP, CUDA). In addition to the basic grid operations such as grid allocation, release, Fourier transform, grid arithmetics, etc., it has also specialized routines for propagating time-dependent Schr\"odinger equation in real or imaginary time. The latter routines are required by libdft library, which solves various types of non-linear Schr\"odinger equations that describe superfluid $^4$He and Bose-Einstein condensates. Libgrid was written by Lauri Lehtovaara, David Mateo, and Jussi Eloranta, and can be freely distributed according to GNU GENERAL PUBLIC LICENSE Version 3 (see doc/GPL.txt). This project was partially supported by National Science Foundation grants: CHE-0949057, CHE-1262306 and DMR-1205734.

\section{Installation}

Installation of libgrid requires the following packages:
\begin{itemize}
\item git (a free and open source distributed version control system)
\item GNU C compiler with OpenMP support (gcc)
\item FFTW 3.x (Fast Fourier Transform package)
\item Grace 2-D plotting program (xmgrace) and its development libraries
\item NETCDF library for converting to CDF format
\end{itemize}
To install these packages on Fedora linux, use (\# prompt implies execution with root privileges): 
\begin{verbatim}
# dnf install git gcc fftw-* grace grace-devel netcdf netcdf-devel
\end{verbatim}
If the system has NVIDIA GPUs, libgrid can use CUDA to accelerate the grid operations. For Fedora-based systems, the propriatary NVIDIA drivers and the CUDA libraries can be obtained from: \url{https://negativo17.org/nvidia-driver/}. This installation is compatible with the default settings in make.conf as described below. Currently, libgrid does not support OpenCL.

To copy the current version of libgrid to subdirectory libgrid, issue (\% implies execution with normal user privileges):
\begin{verbatim}
% git clone https://github.com/jmeloranta/libgrid.git
\end{verbatim}
Change to libgrid directory and review the configuration settings:
\begin{verbatim}
% cd libgrid
% more make.conf
\end{verbatim}
The options specified in this file determine how libgrid will be compiled. OpenMP support is included automatically with COMPILER = gcc.\\

\begin{tabular}{ll}
\textbf{Option} & \textbf{Description}\\
\cline{1-2}
COMPILER & gcc (normal use) or gcc-debug (non-parallel debugging version)\\
REAL & Real floating point precision (float, double or quad precision).\\
     & Note that for libdft use, single precision floats have limited use.\\
INT & Integer number size (int or long)\\
ROOT & Root installation directory (default /usr)\\
CUDA & Set to "yes" if CUDA is installed and "no" if not. The default\\
     & is to auto-detect.\\
CUDA\_DEV & Which CUDA device number to use by default (0 = first GPU).\\
          & Note: GPU device number can be changed in the user code.\\
CUDAINC & Include file directory for CUDA C header files (default\\
        & /usr/include/cuda).\\
CUDALIB & Directory containing the CUDA libraries (default /usr/lib64).\\
CUDA\_HOSTCC & GCC version that is compatible with the current installation of\\
             & CUDA (default /usr/bin/cuda-gcc).\\
CUDA\_CC & NVIDIA GPU architecture (e.g., sm\_50; default auto-detect).\\
CUDA\_FASTMATH & "yes" implies NVCC options: --ftz=true --prec-div=false\\
               & --prec-sqrt=false --fmad=true and "no" implies options:\\
               & --ftz=false --prec-div=true --prec-sqrt=true --fmad=true\\
               & (default no).\\
CUDA\_TPB & Number of CUDA threads per block (GPU architecture\\
          & dependent; default 6).\\
CUDA\_THRADJ & CUDA Thread adjustment for 2-D operations (i.e., Crank\\
             & -Nicolson). GPU architecture dependent value, 2 - 3\\
             & (default 3).\\
CUDA\_DEBUG & Whether to include debug code in libggrid CUDA routines\\
            & ("yes" or "no"; default no).\\
\end{tabular}

\noindent
To compile the library, change to src subdirectory and issue make:
\begin{verbatim}
% cd src
% make -j
\end{verbatim}
Provided that the compilation completed without errors, install the library (as root unless you changed the ROOT above to point to your own directories):
\begin{verbatim}
# make install
\end{verbatim}
To compile the utilities for file format conversions and graphical applications, compile and install the utilities:
\begin{verbatim}
% cd ../util
% make
\end{verbatim}
Once the utilities compile, install them (as root):
\begin{verbatim}
# make install
\end{verbatim}

\noindent
The recommended OpenMP environment variable setting for optimal performance is:
\begin{verbatim}
setenv OMP_SCHEDULE auto
setenv OMP_PROC_BIND TRUE
setenv OMP_WAIT_POLICY ACTIVE
\end{verbatim}

\chapter{Programming interface}

\section{Accessing the library routines}

To access libgrid functions in C program, the following header files should be included:
\begin{verbatim}
#include <grid/grid.h>
#include <grid/au.h>
\end{verbatim}
where the first include file is required and the second optional include makes the following conversion factors available:\\

\begin{longtable}{ll}
GRID\_AUTOANG & Factor to convert from Bohr to \AA{}nstr\"om ($10^{-10}$ m).\\
GRID\_AUTOM & Factor to convert from Bohr to meter.\\
GRID\_AUTOK & Factor to convert from Hartee to Kelvin (energy; $kT$).\\
GRID\_AUTOCM1 & Factor to convert from Hartree to wavenumber.\\
GRID\_HZTOCM1 & Factor to convert from Hz to wavenumber.\\
GRID\_AUTOAMU & Atomic unit mass (electron mass) to atomic mass\\
              & unit (AMU).\\
GRID\_AUTOFS & Atomic unit time to femtosecond.\\
GRID\_AUTOS  & Atomic unit time to second.\\
GRID\_AUTOBAR & Atomic pressure unit (Hartree/Bohr$^2$) to bar.\\
GRID\_AUTOPA & Atomic pressure unit to Pa (Pascal).\\
GRID\_AUTOATM & Atomic pressure unit to atm.\\
GRID\_AUTOMPS & Atomic velocity unit to m/s.\\
GRID\_AUTON & Atomic force unit to Newton (N).\\
GRID\_AUTOVPM & Atomic electric field strength to V/m.\\
GRID\_AUTOPAS & Atomic viscosity unit to Pa s.\\
GRID\_AUKB & Boltzmann constant in a.u. ($k_B$)\\ 
\end{longtable}
\noindent
Note that wherever applicable, librid will use the atomic unit system and the above conversion factors are provided for converting to other systems. To convert from atomic unit to another unit, multiply by the predefined factor above or, divide by it in order to convert the other way around.

To compile and link a program using libgrid, it is most convenient to construct a makefile (note that the \$(CC) line has TAB as the first character):
\begin{verbatim}
include /usr/include/grid/make.conf

test: test.o
    $(CC) $(CFLAGS) -o test test.o $(LDFLAGS)

test.o: test.c
\end{verbatim}
This will compile the program specified in test.c and link the appropriate libraries automatically. Both CFLAGS and LDFLAGS are obtained automatically from libgrid's make.conf. 

\section{Data types}

The libgrid header file defines the real and integer data types automatically according to those requested during the configuration step (make.conf). Instead of using float, double, int, long etc. directly, use REAL to represent a floating point number and INT to introduce the variables (e.g., REAL x, y; INT i;). To define complex number type, use REAL complex. Since the function names in the system math library vary depending on the floating point precision (e.g., expf(), exp(), expl()), libgrid defines the corresponding function in upper case such that is assigned to the function of the requested precision (e.g., EXP(), SIN()). So, in order to call the exponential function, use, e.g., y = EXP(x);. Another place where the size of the REAL and INT data types are required is the scanf/printf standard I/O library routines. To print a REAL number with printf, use, for example, printf("value = " FMT\_R "$\backslash$n");. Or to print an INT use FMT\_I. Inside the library itself, EXPORT keyword is added in front of every function that should be visible to end users (automatic generation of prototypes).

Libgrid has built-in data types for 1-D, 2-D, and 3-D Cartesian REAL ("rgrid") and REAL complex ("cgrid") grids. To allocate such grids in a C program, first introduce them as pointers, e.g., rgrid *abc or cgrid *abc. Then use either rgrid\_alloc() or cgrid\_alloc() functions to allocate the space. For example:
\begin{verbatim}
   cgrid *abc;
   abc = cgrid_alloc(32, 32, 32, 1.0, CGRID3D_PERIODIC_BOUNDARY, NULL);
   ...
   cgrid_free(abc);
\end{verbatim}
would allocate a periodic 3-D grid with dimensions 32x32x32 and spatial grid step length of 1.0 (for more information on the arguments to cgrid\_alloc() in Section 5). To get a 1-D grid, include it as the last dimension, e.g., 1x1x32, or for a 2-D grid use the two last dimensions, 1x32x32. It is important to follow this convention for performance reasons. In the code, coordinate $x$ corresponds to the first index, $y$ to the second, and $z$ to the third. By default, the origin is placed to the center of the grid.

The basic properties of the above rgrid and cgrid data types are explained below.

\subsection{Real grid data type (rgrid)}
Data type rgrid corresponds to a structure with the following members:
\begin{longtable}{p{.33\textwidth} p{.6\textwidth}}
Member & Description\\
\cline{1-2}
REAL *value & Array holding the real grid point data.\\
char id$[32]$ & String describing the grid (comment).\\
size\_t grid\_len & Number of bytes allocated for value array.\\
INT nx & Number of grid points along the 1st grid index ($x$).\\
INT ny & Number of grid points along the 2nd grid index ($y$).\\
INT nz & Number of grid points along the 3rd grid index ($z$).\\
INT nz2 & This is equal to $2\times(nz / 2 + 1)$. Used for indexing *value.\\
REAL step & Grid step length (equal in all directions).\\
REAL x0 & Grid origin $x_0$ (default 0.0).\\
REAL y0 & Grid origin $y_0$ (default 0.0).\\
REAL z0 & Grid origin $z_0$ (default 0.0).\\
REAL kx0 & Grid origin $k_{x,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL ky0 & Grid origin $k_{y,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL kz0 & Grid origin $k_{z,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL (*value\_outside) & Pointer to function returning values outside\\
\phantom{X}(rgrid *, INT, INT, INT) & the grid.\\
void *outside\_params\_ptr & Pointer for passing additional data to value\_outside function.\\
REAL default\_outside\_params & Default REAL value for outside\_params\_ptr.\\
fftwX\_plan plan & FFTW plan for forward FFT transforming the grid (X = f, empty, l).\\
fftwX\_plan iplan & FFTW plan for inverse FFT transforming the grid (X = f, empty, l).\\
cufftHandle cufft\_handle\_r2c & CUFFT handle for forward FFT transform (CUDA).\\
cufftHandle cufft\_handle\_c2r & CUFFT handle for inverse FFT transform (CUDA).\\
REAL fft\_norm & Normalization factor for FFT (without including the step length).\\
REAL fft\_norm2 & Normalization factor for FFT (including the step length).\\
char flag & Field for marking whether the grid is exclusively in use or not (rgrid\_claim() and rgrid\_release()).\\
\end{longtable}

\noindent
Note that rgrid is the same as struct rgrid\_struct type. To reference the value at index (i, j, k) in grid-$>$value, use:
\begin{verbatim}
grid->value[(i * grid->ny + j) * grid->nz2 + k]
\end{verbatim}
The same indexing applies to 1-D (i = j = 0) and 2-D grids with (i = 0). This does not account for the grid boundary condition. Library function rgrid\_value\_at\_index(rgrid *grid, INT i, INT j, INT k) can be used to retrieve the value subject to the chosen boundary condition automatically. To set value for a grid point at (i, j, k), library function rgrid\_value\_to\_index(rgrid *grid, INT i, INT j, INT k, REAL value) can be used. This function does not consider the boundary condition assigned to the grid. Note that a different indexing scheme must be used if the grid is in the reciprocal (Fourier) space:
\begin{verbatim}
grid->value[(i * grid->ny + j) * (grid->nz / 2 + 1) + k]
\end{verbatim}
Alternatively, function rgrid\_cvalue\_at\_index(rgrid *grid, INT i, INT j, INT k) can be used.

\subsection{Complex grid data type (cgrid)}

Data type cgrid corresponds to a structure with the following members:
\begin{longtable}{p{.43\textwidth} p{.55\textwidth}}
Member & Description\\
\cline{1-2}
REAL complex *value & Array holding the complex grid point data.\\
char id[32] & String describing the grid (comment).\\ 
size\_t grid\_len; & Number of bytes allocated for the value array.\\
INT nx & Number of grid points along the 1st grid index ($x$).\\
INT ny & Number of grid points along the 2nd grid index ($y$).\\
INT nz & Number of grid points along the 3rd grid index ($z$).\\
REAL step & Grid step length (equal in all directions).\\
REAL x0 & Grid origin $x_0$ (default 0.0).\\
REAL y0 & Grid origin $y_0$ (default 0.0).\\
REAL z0 & Grid origin $z_0$ (default 0.0).\\
REAL kx0 & Grid origin $k_{x,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL ky0 & Grid origin $k_{y,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL kz0 & Grid origin $k_{z,0}$ in the reciprocal (momentum) space (default 0.0).\\
REAL omega & Rotation frequency around $z$-axis (rotating flow).\\
REAL complex (*value\_outside) & Pointer to function returning values outside\\
\phantom{X}(cgrid *grid, INT, INT, INT) & the grid.\\
void *outside\_params\_ptr & Pointer for passing additional data to value\_outside function.\\
REAL complex default\_outside\_params & Default REAL complex value for outside\_params\_ptr.\\
fftwX\_plan plan & FFTW plan for forward FFT transforming the grid (X = f, empty, l).\\
fftwX\_plan iplan & FFTW plan for inverse FFT transforming the grid (X = f, empty, l).\\
fftwX\_plan implan & Like plan but for non-periodic boundaries (untested).\\
fftwX\_plan iimplan & Like iplan but for non-periodic boundaries (untested).\\
cufftHandle cufft\_handle & CUFFT handle for FFT transforms using CUDA.\\
REAL fft\_norm & Normalization factor for FFT (without including the step length).\\
REAL fft\_norm2 & Normalization factor for FFT (including the step length).\\
char flag & Field for marking whether the grid is exclusively in use or not (cgrid\_claim() and cgrid\_release()).\\
\end{longtable}
\noindent
Indexing of the grid values follow the same convention as for rgrid data type.

\subsection{Wave function data type (wf)}

Wave functions are special objects that contain a complex grid (wave function values) and all other necessary parameters such that it can be propagated in time by using a non-linear Schr\"odinger equation. This data type is mostly used in libdft library.

\begin{longtable}{p{.2\textwidth} p{.75\textwidth}}
Member & Description\\
\cline{1-2}
cgrid *grid & Complex grid containing the wave function values.\\
REAL mass & Particle mass that is represented by this wave function.\\
REAL norm & Requested normalization of the wave function.\\
char boundary & Boundary condition to be used for time propagation. WF\_DIRICHLET\_BOUNDARY = Dirichlet boundary condition, WF\_NEUMANN\_BOUNDARY = Neumann boundary condition, WF\_PERIODIC\_BOUNDARY = Periodic boundary condition.\\
char propagator & Time propagator. WF\_2ND\_ORDER\_PROPAGATOR = 2nd order in time, WF\_4TH\_ORDER\_PROPAGATOR = 4th order in time.\\
\end{longtable}

\chapter{Library functions}

Functions in libgrid are divided into following classes: 1) rgrid\_* (real valued grids; rgrid), 2) cgrid\_* (complex valued grids; cgrid), and 3) grid\_wf\_* (grids describing a wavefunction; wf). These are described in the subsections below. The arguments are listed in the tables in the same order as they are passed to the corresponding functions.

\section{Real grid routines}

\subsection{rgrid\_alloc() -- Allocate a real-valued grid}

This function allocates memory for a real-valued grid. It takes the following arguments:
\begin{longtable}{p{.28\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
INT nx & Number of points on the grid along $x$ (1st index).\\
INT ny & Number of points on the grid along $y$ (2nd index).\\
INT nz & Number of points on the grid along $z$ (3rd index).\\
REAL step & Spatial step length for the grid.\\
REAL *(value\_outside)() & Function for accessing boundary points: RGRID\_DIRICHLET\_BOUNDARY = Dirichlet boundary, RGRID\_NEUMANN\_BOUNDARY = Neumann boundary, RGRID\_PERIODIC\_BOUNDARY  = Periodic boundary. This can also be a user supplied function.\\
void *outside\_params\_ptr & Pointer for passing parameters for the given boundary access function. Use NULL to with the predefined boundary functions.\\
char *id & String ID describing the grid.
\end{longtable}
\noindent
The return value is a pointer to the allocated grid (rgrid *) or NULL on allocation error. \textit{Note that the grid is kept in padded form, which can be directly used for in-place FFT.}

\subsection{rgrid\_claim() -- Mark grid to be in use}

This function sets the flag field in given grid (argument; rgrid *) to non-zero. If the flag was already non-zero, it aborts the program execution. This allows a simple locking of grids when using the ``workspace" model (as in libdft).

\subsection{rgrid\_release() -- Mark grid not in use}

This function sets the flag field in given grid (argument; rgrid *) to zero. If the flag was already zero, it aborts the program execution. This allows a simple locking of grids when using the ``workspace" model (as in libdft).

\subsection{rgrid\_set\_origin() -- Set grid origin}

This function sets the origin (i.e., coordinates for the center of the grid). t takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the origin is to be defined.\\
REAL x0 & $x$ coordinate for the origin.\\
REAL y0 & $y$ coordinate for the origin.\\
REAL z0 & $z$ coordinate for the origin.\\
\end{longtable}
\noindent
This function does not return any value. The mapping between grid indices and coordinates is given by:
\begin{verbatim}
x(i)  = (i - nx / 2) * step - x0
y(j)  = (j - ny / 2) * step - y0
z(k)  = (k - nz / 2) * step - z0
\end{verbatim}
for a grid with dimensions nx$\times$ny$\times$nz, spatial step length step, and origin set at (x0,y0,z0).

\subsection{rgrid\_shift\_origin() -- Shift grid origin}

This function shifts the current origin by given offsets. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the origin is to be defined.\\
REAL x0 & Shift in $x$ coordinate (i.e., add x0 to origin $x$).\\
REAL y0 & Shift in $y$ coordinate (i.e., add y0 to origin $y$).\\
REAL z0 & Shift in $z$ coordinate (i.e., add z0 to origin $z$).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_set\_momentum() -- Set grid origin in reciprocal space}

This function sets the grid origin in momentum space (or the velocity of the frame of reference). It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the momentum origin is to be defined.\\
REAL kx0 & Momentum origin along the $x$ axis.\\
REAL ky0 & Momentum origin along the $y$ axis.\\
REAL kz0 & Momentum origin along the $z$ axis.\\
\end{longtable}
\noindent
Here kx0, ky0 and kz0 can be any real numbers but keep in mind that the grid will only contain the component $k = 0$ if they are multiples of:
$$kx_{0,min} = 2 * \pi / (NX * STEP)$$
$$ky_{0,min} = 2 * \pi / (NY * STEP)$$
$$kz_{0,min} = 2 * \pi / (NZ * STEP)$$
\noindent
where (NX, NY, NZ) specify the grid dimensions and STEP is the grid spatial step length. In terms of velocities, this means that velocities must be multiples of:
$$vx_{0,min} = 2\pi\hbar / (NX * STEP * MASS)$$
$$vy_{0,min} = 2\pi\hbar / (NY * STEP * MASS)$$
$$vz_{0,min} = 2\pi\hbar / (NZ * STEP * MASS)$$
where MASS is the particle mass. This function does not return any value.

\subsection{rgrid\_free() -- Free real-valued grid}

This function takes a pointer to the grid (rgrid *) to be freed as the argument. It has not return value. Note that all allocated memory is automatically released when the program terminates.

\subsection{rgrid\_write() -- Write grid on disk in binary format}

This function will write the contents of a given grid to the disk. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be written to disk.\\
FILE *out & File handle for the file I/O.\\
\end{longtable}
\noindent
This is a binary format file where the data is stored in the following order:
\begin{verbatim}
nx
ny
nz
step
(nx * ny * nz2) number of grid point values
\end{verbatim}
where the grid dimensions are (nx,ny,nz) and nz2 = 2 * (nz / 2 + 1). Note that nz2 must be used as we store the grid in padded format. This function does not return any value.

\subsection{rgrid\_read() -- Read grid from disk in binary format}

This function will read grid data from disk. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid where the data is to be read. If NULL, a grid with the correct dimensions will be allocated. Note that the boundary condition will assigned to periodic by default.\\
FILE *in & File handle for reading the file I/O.\\
\end{longtable}
This function returns a pointer to the grid or NULL pointer on error.

\subsection{rgrid\_write\_grid() -- Write grid to disk with cutoffs along axes}

Write real grid to disk including cuts along the $x$, $y$, and $z$ axes. This function takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
char *basename & Base filename where the suffixes (.x, .y, .z, and .grd) are added.\\
rgrid *grid & Grid to be written to disk.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_read\_grid() -- Read grid from disk}

Read real grid to disk. This function takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be stored in memory.\\
char *file & File name for the file.\\
\end{longtable}
\noindent
This function does not return any value. See also grid\_read().

\subsection{rgrid\_copy() -- Copy grid}

Copy a grid to another where the source and destination grids are determined by the arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *copy & Destination grid.\\
rgrid *grid & Source grid.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_shift() -- Shift grid}

This function shifts a grid spatially by a given amount. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *shifted & Destination grid for the operation.\\
rgrid *grid & Source grid for the operation.\\
REAL xs & Shift grid spatially by this amount along $x$.\\
REAL ys & Shift grid spatially by this amount along $y$.\\
REAL zs & Shift grid spatially by this amount along $z$.\\
\end{longtable}
\noindent
The new positions for the grid are:
\begin{verbatim}
x(new) = x - xs 
y(new) = y - ys 
z(new) = z - zs
\end{verbatim}
\noindent
So, the the point (xs, ys, zs) moves to the center of the grid. This function does not return any value.

\subsection{rgrid\_zero() - Zero grid values}

This function sets all values in a given grid to zero. The only argument it takes is a pointer (rgrid *) to the grid to be zeroed. It returns no value.

\subsection{rgrid\_constant -- Set grid to constant value}

This function is similar to rgrid\_zero() but it allows for an additional argument to specify the value that will be written to the grid. The arguments are as follows:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be set to a constant value.\\
REAL c & Constant value.
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_product\_func() -- Multiply grid by function}

This function multiples a given grid by the values returned by a user specified function. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & Function providing the multiplication values. See below for the arguments to this function.\\
void *farg & Pointer to user specified data that is passed to (*func).\\   
\end{longtable}
\noindent
Function REAL (*func)() takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to user data (provided by *farg above).\\
REAL val & Value at the current grid point.\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
rgrid\_product\_func() function has no return value.

\subsection{rgrid\_map -- Map function on grid}

This function maps a user specified function onto a given grid. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & User specified function providing the mapping. For description of the arguments, see below.\\
void *farg & Pointer to user specified data for (*func)().\\
\end{longtable}
User specified function REAL (*func)() takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to user data (provided by *farg above).\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
rgrid\_map function has no return value.

\subsection{rgrid\_smooth\_map -- Smooth map function onto grid}

This function is like rgrid\_map() but performs linear smoothing on the function. This can be used to weight the values at grid points to produce more accurate integration over the grid. This function takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & Function providing the mapping. The arguments are same as for rgrid\_map() function.\\
void *farg & Pointer to user specified data.\\
INT ns & Number of intermediate points to be used in smoothing.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_adaptive\_map() -- Adaptive smooth map function onto grid}

This function is like rgrid\_smooth\_map() but limits for intermediate steps and requested tolerance can be specified. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Destination grid for the operation.\\
REAL (*func)() & Function providing the mapping. It takes the same arguments as rgrid\_map().\\
void *farg & Pointer to user specified data for (*func)().\\
INT min\_ns & Minimum number of intermediate points to be used in smoothing.\\
INT max\_ns & Maximum number of intermediate points to be used in smoothing.\\
REAL tol & Tolerance for the converge of integral over the function.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_sum() -- Add two grids}

This function adds two grids and stores the output in a third grid (``gridc = grida + gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the summation.\\
rgrid *gridb & 2nd grid for the summation.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_difference() -- Subtract two grids}

This function subtracts two grids and stores the output in a third grid (``gridc = grida - gridb"). It takes the grid pointers as arguments :
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the difference.\\
rgrid *gridb & 2nd grid for the difference.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_product() -- Product of two grids}

This function takes a product of two grids and stores the output in a third grid (``gridc = grida * gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the product.\\
rgrid *gridb & 2nd grid for the product.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_power() -- Rise grid to power}

This function rises a grid to specified power and stores the output in a third grid (``gridb = grida$^\textnormal{exponent}$"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridb & Destination grid.\\
rgrid *grida & Source grid.\\
REAL exponent & Exponent for power operation.\\
\end{longtable}
\noindent
This function has no return value. Note this function uses math library routine POW().

\subsection{rgrid\_abs\_power() -- Rise absolute grid to power}

This function rises absolute value of a grid to specified power and stores the output in a third grid (``gridb = $|$grida$|^\textnormal{exponent}$"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridb & Destination grid.\\
rgrid *grida & Source grid.\\
REAL exponent & Exponent for power operation.\\
\end{longtable}
\noindent
This function has no return value. Note this function uses math library routine POW().

\subsection{rgrid\_division() -- Divide two grids}

This function divides two grids and stores the output in a third grid (``gridc = grida / gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the division.\\
rgrid *gridb & 2nd grid for the division.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_division\_eps() -- Safe divide two grids}

This function ``safely" divides two grids and stores the output in a third grid (``gridc = grida / (gridb + eps)"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st grid for the division.\\
rgrid *gridb & 2nd grid for the division.\\
REAL eps & Small number to be added to the denominator.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_add() - Add constant to grid}

This function adds a constant number to a grid (``grid = grid + c"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid where the constant is added.\\
REAL c & Number to be added.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_multiply() -- Multiply grid by constant}

This function multiplied a grid by constant (``grid = grid * c"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied.\\
REAL c & Number to multiply with.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_add\_and\_multiply() -- Add and multiply grid}

This function adds a constant to grid and multiplies it with another constant (``grid = (grid + ca) * cm"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied.\\
REAL ca & Constant to be added to the grid.\\
REAL cm & Constant to be multiplied with the grid.\\
\end{longtable}
\noindent
This function has no return value. Note that the adding and multiplying are done in different order as in rgrid\_multiply\_and\_add().

\subsection{rgrid\_multiply\_and\_add() -- Multiply and add grid}

This function adds a constant to grid and multiplies it with another constant (``grid = cm * grid + ca"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied.\\
REAL cm & Constant to be multiplied with the grid.\\
REAL ca & Constant to be added to the grid.\\
\end{longtable}
\noindent
This function has no return value. Note that the adding and multiplying are done in different order as in rgrid\_add\_and\_multiply().

\subsection{rgrid\_add\_scaled() -- Add scaled grids}

This function adds two grids such that the second grid is scaled (``gridc = gridc + d * grida"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Source/destination grid for the operation.\\
REAL d & Multiplier for grida.\\
rgrid *grida & Source grid for the operation.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_add\_scaled\_product() -- Add scaled product of grids}

This function performs operation: ``gridc = gridc + d * grida * gridb". It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Source/destination grid.\\
REAL d & Constant multiplier.\\
rgrid *grida & 2nd source grid.\\
rgrid *gridb & 3rd source grid.\\      
\end{longtable}
\noindent
This function has no return value.

\subsection{rgrid\_operate\_one() -- Operate on grid}

Operate on a grid by a given operator: gridc = O(grida). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & Source grid.\\
REAL (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
\end{longtable}
\noindent
The user specified operator (*operator)() maps the value at a grid point to another real number. The arguments to this function pointer are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL val & Value at the current grid point.\\
void *params & Pointer to use supplied parameters.\\
\end{longtable}
\noindent
rgrid\_operate\_one() function has no return value.

\subsection{rgrid\_operate\_one\_product() -- Operate and multiply grids}

This function  operates on a grid by a given operator and then multiplies by another grid: ``gridc = gridb * O(grida)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *gridb & Multiply by this grid.\\
rgrid *grida & Multiply by O(grida).\\
REAL (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL val & Value at the current grid point.\\
void *params & Pointer to use supplied parameters.\\
\end{longtable}
\noindent
rgrid\_operate\_one() function has no return value.

\subsection{rgrid\_operate\_two() -- Operate on two grids}

This function  operates on a grid by a given operator that depends on two grids: ``gridc = O(grida, gridb)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *gridc & Destination grid.\\
rgrid *grida & 1st source grid for operator.\\
rgrid *gridb & 2nd source grid for operator.\\
REAL (*operator)() & Function operating on grida and gridb. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL aval & Value at the current grid point (grida).\\
REAL bval & Value at the current grid point (gridb).\\
\end{longtable}
\noindent
rgrid\_operate\_two() function has no return value.

\subsection{rgrid\_transform\_one() -- Transform grid}

This function operates directly on a grid by a given operator:  "O(grid)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Source/destination grid.\\
void (*operator)() & Function operating on grid. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *val & Value at the current grid points (note: pointer).\\
\end{longtable}
\noindent
rgrid\_transform\_one() function has no return value.

\subsection{rgrid\_transform\_two() -- Transform two grids}

This function operates directly on two grids by a given operator: "O(grida,gridb)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid to be operated.\\
rgrid *gridb & 2nd grid to be operated.\\
void *(operator) & Operator for grid and gridb. The arguments to this function are given below.\\
\end{longtable}
\noindent
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *avalue & Pointer to current grida value.\\
REAL *bvalue & Pointer to current gridb value.\\
\end{longtable}
\noindent
rgrid\_transform\_two() function has no return value.

\subsection{rgrid\_integral() -- Integrate over grid}

This function integrates over the given grid. It takes the grid pointer (rgrid *) as the only argument and returns the value of the integral. 

\subsection{rgrid\_integral\_region() -- Integrate over grid region}

This function integrates over the given grid region. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be integrated.\\
REAL xl & Lower limit for $x$.\\
REAL xu & Upper limit for $x$.\\
REAL yl & Lower limit for $y$.\\
REAL yu & Upper limit for $y$.\\
REAL zl & Lower limit for $z$.\\
REAL zu & Upper limit for $z$.\\
\end{longtable}
\noindent
This function returns the value of the integral. 

\subsection{rgrid\_integral\_of\_square() -- Integrate grid squared}

This function integrates over the given grid squared (``grid$^2$"). It takes the grid pointer (rgrid *) as the only argument and returns the value of the integral.

\subsection{rgrid\_integral\_of\_product() -- Overlap between grids}

Calculate the overlap between two grids (i.e., integral over the product of the grids). This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid for integration.\\
rgrid *gridb & 2nd grid for integration.\\
\end{longtable}
\noindent
This function returns the value of the overlap integral (REAL).

\subsection{rgrid\_grid\_expectation\_value() -- Grid expectation value}

Calculate the expectation value of a grid over a given probability density: integral(gridb * $|$grida$|^2$). This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid for integration ($|$grida$|^2$).\\
rgrid *gridb & 2nd grid for integration.\\
\end{longtable}
\noindent
This function returns the value of the overlap integral (REAL).

\subsection{rgrid\_grid\_expectation\_value\_func() -- Expectation value of function over grid squared}

Calculate the expectation value of a function over grid squared: int grida func() grida = int func() grida$^2$. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL (*func)() & Function to be averaged. The arguments to this functions are given below.\\
rgrid *grida & Grid giving the probability density (grida$^2$).\\
\end{longtable}
\noindent
The arguments to (*func)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to use supplied data to the function.\\
REAL val & Value of grida at the current point.\\
REAL x & Current value of $x$.\\
REAL y & Current value of $y$.\\
REAL z & Current value of $z$.\\
\end{longtable}
\noindent
This user supplied function return the function value to be averaged (REAL). Function rgrid\_grid\_expectation\_value\_func() returns the expectation value (REAL).

\subsection{rgrid\_weighted\_integral() -- Integral of grid over weighting function}

Integrate over grid multiplied by weighting function: int grid w(x,y,z). This function takes the arguments as:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be integrated over.\\
REAL (*weight)() & Function defining the weight. The arguments to this function are given below.\\
void *farg & Use supplied argument to the weight function.\\
\end{longtable}
\noindent
The weight function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
void *farg & User supplied data to (*weight)().\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
Function rgrid\_weighted\_integral() returns the value of the integral (REAL).

\subsection{rgrid\_weighted\_integral\_of\_square() -- Integral of grid squared over weighting function}

Integrate over grid squared multiplied by weighting function: int grid$^2$ w(x,y,z). This function takes the arguments as:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be integrated over.\\
REAL (*weight)() & Function defining the weight. The arguments to this function are given below.\\
void *farg & Use supplied argument to the weight function.\\
\end{longtable}
\noindent
The weight function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
void *farg & User supplied data to (*weight)().\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
Function rgrid\_weighted\_integral\_of\_square() returns the value of the integral (REAL).

\subsection{rgrid\_fd\_gradient\_x() -- Differentiate grid with respect to x}

Differentiate a grid with respect to $x$ (central difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be differentiated.\\
rgrid *gradient & Grid containing the derivative (output).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_gradient\_y() -- Differentiate grid with respect to y}

Differentiate a grid with respect to $y$ (central difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be differentiated.\\
rgrid *gradient & Grid containing the derivative (output).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_gradient\_z() -- Differentiate grid with respect to z}

Differentiate a grid with respect to $z$ (central difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be differentiated.\\
rgrid *gradient & Grid containing the derivative (output).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_gradient() -- gradient of a grid}

Calculate gradient of a grid (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & grid to be differentiated.\\
rgrid *gradient\_x & $x$ component derivative grid.\\
rgrid *gradient\_y & $y$ component derivative grid.\\
rgrid *gradient\_z & $z$ component derivative grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_laplace() -- Laplace of a grid}

Calculate Laplacian of a grid (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & grid to be differentiated.\\
rgrid *laplace & Grid containing the Laplacian.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_laplace\_x() -- 2nd derivative of a grid (x)}

Calculate 2nd derivative of a grid with respect to $x$ (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & grid to be differentiated.\\
rgrid *laplacex & Grid containing the 2nd derivative.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_laplace\_y() -- 2nd derivative of a grid (y)}

Calculate 2nd derivative of a grid with respect to $y$ (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & grid to be differentiated.\\
rgrid *laplacey & Grid containing the 2nd derivative.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_laplace\_z() -- 2nd derivative of a grid (z)}

Calculate 2nd derivative of a grid with respect to $z$ (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & grid to be differentiated.\\
rgrid *laplacez & Grid containing the 2nd derivative.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fd\_gradient\_dot\_gradient() -- Dot product of gradient of grid with itself}

This function calculates dot product of the gradient of the grid with itself: $\nabla$ grid $\cdot$ $\nabla$ grid (finite difference). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid  & Source grid for the operation.\\
rgrid *grad\_dot\_grad & Destination grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_print() -- Print contents of grid in ASCII}

This function print a given grid into file in ASCII format. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be printed.\\
FILE *out & Output file pointer.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_fft() -- Fast forward Fourier transform of grid}

Perform forward Fourier transformation of a grid. The grid for FFT is given as the only argument (rgrid *). The grid is overwritten by the result. No normalization of the output is performed. Note that the indexing of the complex data is different from the real data (see FFTW manual). The function does not return any value. 

\subsection{rgrid\_inverse\_fft() -- Fast inverse Fourier transform of grid}

Perform inverse Fourier transformation of a grid. The grid for FFT is given as the only argument (rgrid *). The grid is overwritten by the result. No normalization of the output is performed. The function does not return any value.

\subsection{rgrid\_scaled\_inverse\_fft() -- Scaled fast inverse Fourier transform of grid}

Perform scaled inverse Fourier transformation of a grid. The grid for FFT is given as the first argument (rgrid *) followed by normalization constant (i.e., transformed data multiplied by this value). The grid is overwritten by the result. The function does not return any value.

\subsection{rgrid\_inverse\_fft\_norm() -- Normalized fast inverse Fourier transform of grid}

Perform normalized inverse Fourier transformation of a grid. The grid for FFT is given as the only argument (rgrid *). The grid is overwritten by the result. The output is normalized (i.e., doing forward FFT followed by this yields the original data). The function does not return any value.

\subsection{rgrid\_fft\_convolute() -- Convolution in reciprocal space}

Multiply two grids that are in reciprocal space. Convolution between grida and gridb can be obtained by:
\begin{verbatim}
 rgrid_fft(grida);
 rgrid_fft(gridb);
 rgrid_convolute(gridc, grida, gridb);
 rgrid_inverse_fft(gridc);
\end{verbatim}
The output will be in gridc. This function takes three arguments as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grida & 1st grid to be convoluted.\\ 
rgrid *gridb & 2nd grid to be convoluted.\\
rgrid *gridc & Output.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_multiply\_fft() -- Multiply grid in reciprocal space by constant}

Multiply grid in reciprocal space by a constant (grid-$>$value is complex). The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be multiplied. Note that the values are actually complex.\\
REAL c & Multiply the grid by this value.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_value\_at\_index() -- Access grid point at given index}

This function returns grid point value at a given index (follows boundary condition). The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be accessed.\\
INT i & Index along $x$.\\
INT j & Index along $y$.\\
INT k & Index along $z$.\\
\end{longtable}
\noindent
This function returns the grid point value (REAL). Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{rgrid\_value\_to\_index() -- Set value to grid at given index}

This function puts a specified value to a given index location in a grid. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be accessed.\\
INT i & 1st index ($x$).\\
INT j & 2nd index ($y$).\\
INT k & 3rd index ($z$).\\
REAL value & Value to be set at grid location (i, j, k).\\
\end{longtable}
\noindent
This function does not return any value. Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{rgrid\_cvalue\_at\_index() -- Access grid point in reciprocal space}

This function returns (complex) grid point value at a given index when the grid is in reciprocal space (i.e., it has been Fourier transformed). It takes arguments as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & grid to be accessed. The data is complex (after FFT).\\
INT i & 1st index ($x$).\\
INT j & 2nd index ($y$).\\
INT k & 3rd index ($z$).\\
\end{longtable}
\noindent
The function returns (REAL complex) value at grid point (i, j, k). Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{rgrid\_value() -- Access grid point at (x, y, z)}

This function returns grid point at given (x, y, z) point where linear interpolation is used between the grid points. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be accessed.\\
REAL x & $x$ value.\\
REAL y & $y$ value.\\
REAL z & $z$ value.\\
\end{longtable}
\noindent
This function returns (REAL) value at grid position (x, y, z). Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{rgrid\_extrapolate() -- Extrapolate between two grid sizes}

This function extrapolates between grids of different sizes (both size and step) using linear interpolation. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *dest & Destination grid.\\
rgrid *src  & Source grid.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_rotate\_z() -- Rotate contents of grid around $z$-axis}

Rotate contents of a grid by a given angle around the $z$-axis. The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *in & The original grid (to be rotated).\\                                                                                
rgrid *out & Output grid (rotated grid).\\
REAL th & Rotation angle in radians.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_max() -- Largest value on grid}

Return the largest value contained in a grid (REAL). This function takes only one argument (rgrid *grid), which specifies the grid to be searched.

\subsection{rgrid\_max() -- Smallest value on grid}

Return the smallest value contained in a grid (REAL). This function takes only one argument (rgrid *grid), which specifies the grid to be searched.

\subsection{rgrid\_random() -- Add random noise to grid}

Add random numbers to given grid within [-scale,+scale[. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid where random numbers will be added.\\
REAL scale & Specify the scale for random numbers.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_poisson() -- Solve Poisson equation}

This routine solves Poisson equation ($\Delta f = u$) subject to periodic boundaries. It
uses finite difference for Laplacian (7 point) and FFT. It takes one grid (rgrid *) as argument, which on entry describes the right hand side function ($u$). On exit, this grid is replaced by the solution ($f$). The function does not return any value.

\subsection{rgrid\_div() -- Divergence of vector field}

Calculate divergence of a given vector field. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *div & Result grid.\\
rgrid *fx  & $x$ component of the vector field.\\
rgrid *fy  & $y$ component of the vector field.\\
rgrid *fz  & $z$ component of the vector field.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_rot() -- Rot of vector field}

Calculate rot of a given vector field. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *rotx & Result grid ($x$ component).\\
rgrid *roty & Result grid ($y$ component).\\
rgrid *rotz & Result grid ($z$ component).\\
rgrid *fx  & $x$ component of the vector field.\\
rgrid *fy  & $y$ component of the vector field.\\
rgrid *fz  & $z$ component of the vector field.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_abs\_rot() -- Norm of rot of vector field}

Calculate norm of rot of a given vector field ($|$rot$|$). The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *rot & Result grid.\\
rgrid *fx  & $x$ component of the vector field.\\
rgrid *fy  & $y$ component of the vector field.\\
rgrid *fz  & $z$ component of the vector field.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_dealias23() -- Dealias in Fourier space (2/3 rule)}

This function performs de-alias of a grid in Fourier space by the 2/3 rule: zero high wavenumber components between: [n/2 - n/3, n/2 + n/3] in each direction (except the last dimension is [nz - nz/3, nz]). The only argument is the grid (rgrid *; in reciprocal space) that will be operated on. The function does not return any value.

\subsection{rgrid\_ipower() -- Rise grid to integer power}

Raise given grid to a specified integer power (fast -- not using POW()). The following arguments are required:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *dst & Destination grid.\\
rgrid *src & Source grid for operation.\\
INT exponent & Exponent to be used. This value can be negative.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_threshold\_clear() -- Set grid value based on threshold values}

Set a value to given grid points based on upper/lower limit thresholds of another grid (which may correspond to same grids). This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *dest & Destination grid.\\
rgrid *src  & Source grid for evaluating the thresholds.\\
REAL ul & Upper limit threshold for the operation.\\
REAL ll & Lower limit threshold for the operation.\\
REAL uval & Value to set when the upper limit was exceeded.\\
REAL lval & Value to set when the lower limit was exceeded.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{rgrid\_hodge() -- Hodge's decomposition of vector field}

Decompose a vector field into ``compressible" ($u$) and ``incompressible" ($w$) parts: $v = w + u = w + \nabla q$ where $\nabla\cdot w = 0$ and $u = \nabla q$ (Hodge's decomposition). This is performed by solving the Poisson equation: $\Delta q = \nabla\cdot v$. Then $u = \nabla q$ and the incompressible part is $w = v - u$. Given vector field $v$, this function computes $u$ and $w$. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *vx & $x$ component of the vector field to be decomposed.\\
rgrid *vy & $y$ component of the vector field to be decomposed.\\
rgrid *vz & $z$ component of the vector field to be decomposed.\\
rgrid *ux & $x$ component of the compressible vector field.\\
rgrid *uy & $y$ component of the compressible vector field.\\
rgrid *uz & $z$ component of the compressible vector field.\\
rgrid *wx & $x$ component of the incompressible vector field.\\
rgrid *wy & $y$ component of the incompressible vector field.\\
rgrid *wz & $z$ component of the incompressible vector field.\\
\end{longtable}
\noindent
This function does not return any value. By noting that $\nabla\times v = \nabla\times w + \nabla\times u = \nabla\times w + \nabla\times\nabla q = \nabla\times w$, we can see that the incompressible part includes rotation whereas the compressible part is irrotational.

\subsection{rgrid\_spherical\_average() -- Compute spherical average of grid in real space}

Compute spherical shell average in real space with respect to the grid origin with the result stored in 1-D grid:
$$f(r) = \frac{1}{4\pi r^2}\int \left(f_1(r, \theta, \phi) + f_2(r, \theta, \phi) + f_3(r, \theta, \phi)\right) \sin(\theta) d\theta d\phi$$
This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *input1 & Input grid 1 ($f_1$) for spherical averaging.\\
rgrid *input2 & Input grid 2 ($f_2$) for spherical averaging (may be NULL).\\
rgrid *input3 & Input grid 3 ($f_3$) for spherical averaging (may be NULL).\\
REAL *bins & 1-D array for the spherically averaged values. This is an array with dimenion equal to nbins (below).\\
REAL binstep & Binning step length.\\
INT nbins & Number of bins allocated in bins.\\
char volel & Whether to include multiplication by the volume element ($4\pi r^2$). 1 = Multiply by the volume element; 0 = no multiplication (i.e., calculate radial average).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{rgrid\_spherical\_average\_reciprocal() -- Compute spherical average of grid in reciprocal space}

Compute spherical shell average in reciprocal space with respect to the grid origin with the result stored in 1-D grid:
$$E(\mathbf{k}) = \frac{1}{4\pi k^2} \int |E(k, \theta_k, \phi_k)|^2 sin(\theta_k) d\theta_k d\phi_k$$
This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *input & Input grid for spherical averaging, but this is complex data (i.e., after rgrid\_fft()).\\
REAL *bins & 1-D array for the spherically averaged values. This is an array with dimenion equal to nbins (below).\\
REAL binstep & Binning step length for $k$.\\
INT nbins & Number of bins allocated in bins.\\
char volel & Whether to include multiplication by the volume element ($4\pi k^2$). 1 = Multiply by the volume element; 0 = no multiplication (i.e., calculate radial average).\\
\end{longtable}
\noindent
This function does not return any value. 

\section{Complex grid routines}

\subsection{cgrid\_alloc() -- Allocate a complex-valued grid}

This function allocates memory for a complex-valued grid. It takes the following arguments:
\begin{longtable}{p{.41\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT nx & Number of points on the grid along $x$ (1st index).\\
INT ny & Number of points on the grid along $y$ (2nd index).\\
INT nz & Number of points on the grid along $z$ (3rd index).\\
REAL step & Spatial step length for the grid.\\
REAL complex *(value\_outside)() & Function for accessing boundary points: CGRID\_DIRICHLET\_BOUNDARY = Dirichlet boundary, CGRID\_NEUMANN\_BOUNDARY = Neumann boundary, CGRID\_PERIODIC\_BOUNDARY  = Periodic boundary. This can also be a user supplied function.\\
void *outside\_params\_ptr & Pointer for passing parameters for the given boundary access function. Use NULL to with the predefined boundary functions.\\
char *id & String ID describing the grid.
\end{longtable}
\noindent
The return value is a pointer to the allocated grid (cgrid *) or NULL on allocation error.

\subsection{cgrid\_claim() -- Mark grid to be in use}

This function sets the flag field in given grid (argunent; cgrid *) to non-zero. If the flag was already non-zero, it aborts the program execution. This allows a simple locking of grids when using the ``workspace" model (as in libdft).

\subsection{cgrid\_release() -- Mark grid not in use}

This function sets the flag field in given grid (argument; cgrid *) to zero. If the flag was already zero, it aborts the program execution. This allows a simple locking of grids when using the ``workspace" model (as in libdft).

\subsection{cgrid\_set\_origin() -- Set grid origin}

This function sets the origin (i.e., coordinates for the center of the grid). t takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.5\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid for which the origin is to be defined.\\
REAL x0 & $x$ coordinate for the origin.\\
REAL y0 & $y$ coordinate for the origin.\\
REAL z0 & $z$ coordinate for the origin.\\
\end{longtable}
\noindent
This function does not return any value. The mapping between grid indices and coordinates is given by:
\begin{verbatim}
x(i)  = (i - nx / 2) * step - x0
y(j)  = (j - ny / 2) * step - y0
z(k)  = (k - nz / 2) * step - z0
\end{verbatim}
for a grid with dimensions nx$\times$ny$\times$nz, spatial step length step, and origin set at (x0, y0, z0).

\subsection{cgrid\_shift\_origin() -- Shift grid origin}

This function shifts the current origin by given offsets. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid for which the origin is to be defined.\\
REAL x0 & Shift in $x$ coordinate (i.e., add x0 to origin $x$).\\
REAL y0 & Shift in $y$ coordinate (i.e., add y0 to origin $y$).\\
REAL z0 & Shift in $z$ coordinate (i.e., add z0 to origin $z$).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_set\_momentum() -- Set grid origin in reciprocal space}

This function sets the grid origin in momentum space (or the velocity of the frame of reference). It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid for which the momentum origin is to be defined.\\
REAL kx0 & Momentum origin along the $x$ axis.\\
REAL ky0 & Momentum origin along the $y$ axis.\\
REAL kz0 & Momentum origin along the $z$ axis.\\
\end{longtable}
\noindent
Here kx0, ky0 and kz0 can be any real numbers but keep in mind that the grid will only contain the component $k = 0$ if they are multiples of:
$$kx_{0,min} = 2 * \pi / (NX * STEP)$$
$$ky_{0,min} = 2 * \pi / (NY * STEP)$$
$$kz_{0,min} = 2 * \pi / (NZ * STEP)$$
\noindent
where (NX, NY, NZ) specify the grid dimensions and STEP is the grid spatial step length. In terms of velocities, this means that velocities must be multiples of:
$$vx_{0,min} = 2\pi\hbar / (NX * STEP * MASS)$$
$$vy_{0,min} = 2\pi\hbar / (NY * STEP * MASS)$$
$$vz_{0,min} = 2\pi\hbar / (NZ * STEP * MASS)$$
where MASS is the particle mass. This function does not return any value.

\subsection{cgrid\_free() -- Free real-valued grid}

This function takes a pointer to the grid (cgrid *) to be freed as the argument. It has not return value. Note that all allocated memory is automatically released when the program terminates.

\subsection{cgrid\_write() -- Write grid on disk in binary format}

This function will write the contents of a given grid to the disk. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be written to disk.\\
FILE *out & File handle for the file I/O.\\
\end{longtable}
\noindent
This is a binary format file where the data is stored in the following order:
\begin{verbatim}
nx
ny
nz
step
(nx * ny * nz) number of complex grid point values
\end{verbatim}
where the grid dimensions are (nx,ny,nz). This function does not return any value.

\subsection{cgrid\_read() -- Read grid from disk in binary format}

This function will read grid data from disk. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid where the data is to be read. If NULL, a grid with the correct dimensions will be allocated. Note that the boundary condition will assigned to periodic by default.\\
FILE *in & File handle for reading the file I/O.\\
\end{longtable}
This function returns a pointer to the grid or NULL pointer on error.

\subsection{cgrid\_write\_grid() -- Write grid to disk with cutoffs along axes}

Write complex grid to disk including cuts along the $x$, $y$, and $z$ axes. This function takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
char *basename & Base filename where the suffixes (.x, .y, .z, and .grd) are added.\\
cgrid *grid & Grid to be written to disk.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_read\_grid() -- Read grid from disk}

Read complex grid from disk. This function takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Destination grid.\\
char *file & File name for the grid file to be read.\\
\end{longtable}
\noindent
This function does not return any value. See also cgrid\_read().

\subsection{cgrid\_copy() -- Copy grid}

Copy a grid to another where the source and destination grids are determined by the arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *copy & Destination grid.\\
cgrid *grid & Source grid.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_conjugate() -- Complex conjugate of grid}

This function takes complex conjugate of a given grid, conjugate = grid$^*$. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *conjugate & Destination for complex conjugated grid.\\
cgrid *grid & Source grid for the operation.\\
\end{longtable}
\noindent
This function returns no value.

\subsection{cgrid\_shift() -- Shift grid}

This function shifts a grid spatially by a given amount. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *shifted & Destination grid for the operation.\\
rgrid *grid & Source grid for the operation.\\
REAL xs & Shift grid spatially by this amount along $x$.\\
REAL ys & Shift grid spatially by this amount along $y$.\\
REAL zs & Shift grid spatially by this amount along $z$.\\
\end{longtable}
\noindent
The new positions for the grid are:
\begin{verbatim}
x(new) = x - xs 
y(new) = y - ys 
z(new) = z - zs
\end{verbatim}
\noindent
So, the the point (xs, ys, zs) moves to the center of the grid. This function does not return any value.

\subsection{cgrid\_zero() - Zero grid values}

This function sets all values (both real and imaginary parts) in a given grid to zero. The only argument it takes is a pointer (cgrid *) to the grid to be zeroed. It returns no value.

\subsection{cgrid\_constant -- Set grid to constant value}

This function is similar to cgrid\_zero() but it allows for an additional argument to specify the value that will be written to the grid. The arguments are as follows:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be set to a constant value.\\
REAL complex c & Constant value.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_product\_func() -- Multiply grid by function}

This function multiples a given grid by the values returned by a user specified function. It takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Destination grid for the operation.\\
REAL complex (*func)() & Function providing the multiplication values. See below for the arguments to this function.\\
void *farg & Pointer to user specified data that is passed to (*func).\\   
\end{longtable}
\noindent
Function REAL complex (*func)() takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to user data (provided by *farg above).\\
REAL complex val & Value at the current grid point.\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
cgrid\_product\_func() function has no return value.

\subsection{cgrid\_map -- Map function on grid}

This function maps a user specified function onto a given grid. It takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Destination grid for the operation.\\
REAL complex (*func)() & User specified function providing the mapping. For description of the arguments, see below.\\
void *farg & Pointer to user specified data for (*func)().\\
\end{longtable}
User specified function REAL complex (*func)() takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to user data (provided by *farg above).\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
rgrid\_map function has no return value.

\subsection{cgrid\_smooth\_map -- Smooth map function onto grid}

This function is like cgrid\_map() but performs linear smoothing on the function. This can be used to weight the values at grid points to produce more accurate integration over the grid. This function takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Destination grid for the operation.\\
REAL complex (*func)() & Function providing the mapping. The arguments are same as for rgrid\_map() function.\\
void *farg & Pointer to user specified data.\\
INT ns & Number of intermediate points to be used in smoothing.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_adaptive\_map() -- Adaptive smooth map function onto grid}

This function is like cgrid\_smooth\_map() but limits for intermediate steps and requested tolerance can be specified. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Destination grid for the operation.\\
REAL complex (*func)() & Function providing the mapping. It takes the same arguments as cgrid\_map().\\
void *farg & Pointer to user specified data for (*func)().\\
INT min\_ns & Minimum number of intermediate points to be used in smoothing.\\
INT max\_ns & Maximum number of intermediate points to be used in smoothing.\\
REAL tol & Tolerance for the converge of integral over the function.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_sum() -- Add two grids}

This function adds two grids and stores the output in a third grid (``gridc = grida + gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.75\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & 1st grid for the summation.\\
cgrid *gridb & 2nd grid for the summation.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_difference() -- Subtract two grids}

This function subtracts two grids and stores the output in a third grid (``gridc = grida - gridb"). It takes the grid pointers as arguments :
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & 1st grid for the difference.\\
cgrid *gridb & 2nd grid for the difference.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_product() -- Product of two grids}

This function takes a product of two grids and stores the output in a third grid (``gridc = grida * gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & 1st grid for the product.\\
cgrid *gridb & 2nd grid for the product.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_power() -- Rise grid to power}

This function rises a grid to specified power and stores the output in a third grid (``gridb = grida$^\textnormal{exponent}$"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridb & Destination grid.\\
cgrid *grida & Source grid.\\
REAL exponent & Exponent for power operation.\\
\end{longtable}
\noindent
This function has no return value. Note this function uses math library routine POW().

\subsection{cgrid\_abs\_power() -- Rise absolute grid to power}

This function rises absolute value of a grid to specified power and stores the output in a third grid (``gridb = $|$grida$|^\textnormal{exponent}$"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridb & Destination grid.\\
cgrid *grida & Source grid.\\
REAL exponent & Exponent for power operation.\\
\end{longtable}
\noindent
This function has no return value. Note this function uses math library routine POW().

\subsection{cgrid\_division() -- Divide two grids}

This function divides two grids and stores the output in a third grid (``gridc = grida / gridb"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & 1st grid for the division.\\
cgrid *gridb & 2nd grid for the division.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_division\_eps() -- Safe divide two grids}

This function ``safely" divides two grids and stores the output in a third grid (``gridc = grida / (gridb + eps)"). It takes the grid pointers as arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & 1st grid for the division.\\
cgrid *gridb & 2nd grid for the division.\\
REAL eps & Small number to be added to the denominator.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_conjugate\_product() -- Conjugate product of two grids}

This function calculates conjugate product of two grids: gridc = CONJ(grida) * gridb. The function takes the following arguments: 
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}                                                                                                                                                                                                               
cgrid *gridc & Destination grid.\\                                                                                          
cgrid *grida & 1st source grid (conjugated).\\                                                                                            
cgrid *gridb & 2nd source grid.\\                                                                                            
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_add() - Add constant to grid}

This function adds a constant number to a grid (``grid = grid + c"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid where the constant is added.\\
REAL complex c & Number to be added.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_multiply() -- Multiply grid by constant}

This function multiplied a grid by constant (``grid = grid * c"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be multiplied.\\
REAL complex c & Number to multiply with.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_add\_and\_multiply() -- Add and multiply grid}

This function adds a constant to grid and multiplies it with another constant (``grid = (grid + ca) * cm"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be multiplied.\\
REAL complex ca & Constant to be added to the grid.\\
REAL complex cm & Constant to be multiplied with the grid.\\
\end{longtable}
\noindent
This function has no return value. Note that the adding and multiplying are done in different order as in cgrid\_multiply\_and\_add().

\subsection{cgrid\_multiply\_and\_add() -- Multiply and add grid}

This function adds a constant to grid and multiplies it with another constant (``grid = cm * grid + ca"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be multiplied.\\
REAL complex cm & Constant to be multiplied with the grid.\\
REAL complex ca & Constant to be added to the grid.\\
\end{longtable}
\noindent
This function has no return value. Note that the adding and multiplying are done in different order as in cgrid\_add\_and\_multiply().

\subsection{cgrid\_add\_scaled() -- Add scaled grids}

This function adds two grids such that the second grid is scaled (``gridc = gridc + d * grida"). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Source/destination grid for the operation.\\
REAL complex d & Multiplier for grida.\\
cgrid *grida & Source grid for the operation.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_add\_scaled\_product() -- Add scaled product of grids}

This function performs operation: ``gridc = gridc + d * grida * gridb". It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Source/destination grid.\\
REAL complex d & Constant multiplier.\\
cgrid *grida & 2nd source grid.\\
cgrid *gridb & 3rd source grid.\\      
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_operate\_one() -- Operate on grid}

Operate on a grid by a given operator: gridc = O(grida). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & Source grid.\\
REAL complex (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
\end{longtable}
\noindent
The user specified operator (*operator)() maps the value at a grid point to another real number. The arguments to this function pointer are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL complex val & Value at the current grid point.\\
void *params & Pointer to use supplied parameters.\\
\end{longtable}
\noindent
cgrid\_operate\_one() function has no return value.

\subsection{cgrid\_operate\_one\_product() -- Operate and multiply grids}

This function  operates on a grid by a given operator and then multiplies by another grid: ``gridc = gridb * O(grida)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *gridb & Multiply by this grid.\\
cgrid *grida & Multiply by O(grida).\\
REAL complex (*operator)() & Function operating on grida. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL complex val & Value at the current grid point.\\
void *params & Pointer to use supplied parameters.\\
\end{longtable}
\noindent
cgrid\_operate\_one() function has no return value.

\subsection{cgrid\_operate\_two() -- Operate on two grids}

This function  operates on a grid by a given operator that depends on two grids: ``gridc = O(grida, gridb)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *gridc & Destination grid.\\
cgrid *grida & 1st source grid for operator.\\
cgrid *gridb & 2nd source grid for operator.\\
REAL complex (*operator)() & Function operating on grida and gridb. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL complex aval & Value at the current grid point (grida).\\
REAL complex bval & Value at the current grid point (gridb).\\
\end{longtable}
\noindent
cgrid\_operate\_two() function has no return value.

\subsection{cgrid\_transform\_one() -- Transform grid}

This function operates directly on a grid by a given operator:  "O(grid)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Source/destination grid.\\
void (*operator)() & Function operating on grid. Arguments for this user specified function are given below.\\
\end{longtable}
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL complex *val & Value at the current grid points (note: pointer).\\
\end{longtable}
\noindent
cgrid\_transform\_one() function has no return value.

\subsection{cgrid\_transform\_two() -- Transform two grids}

This function operates directly on two grids by a given operator: "O(grida,gridb)". The arguments to this function are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grida & 1st grid to be operated.\\
cgrid *gridb & 2nd grid to be operated.\\
void *(operator) & Operator for grid and gridb. The arguments to this function are given below.\\
\end{longtable}
\noindent
The arguments to (*operator)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL complex *avalue & Pointer to current grida value.\\
REAL complex *bvalue & Pointer to current gridb value.\\
\end{longtable}
\noindent
cgrid\_transform\_two() function has no return value.

\subsection{cgrid\_integral() -- Integrate over grid}

This function integrates over the given grid. It takes the grid pointer (cgrid *) as the only argument and returns the value of the integral (REAL complex). 

\subsection{cgrid\_integral\_region() -- Integrate over grid region}

This function integrates over the given grid region. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be integrated.\\
REAL xl & Lower limit for $x$.\\
REAL xu & Upper limit for $x$.\\
REAL yl & Lower limit for $y$.\\
REAL yu & Upper limit for $y$.\\
REAL zl & Lower limit for $z$.\\
REAL zu & Upper limit for $z$.\\
\end{longtable}
\noindent
This function returns the value of the integral (REAL complex). 

\subsection{cgrid\_integral\_of\_square() -- Integrate grid squared}

This function integrates over the given grid squared (``grid$^2$"). It takes the grid pointer (cgrid *) as the only argument and returns the value of the integral (REAL).

\subsection{cgrid\_integral\_of\_conjugate\_product() -- Overlap between grids}

Calculate the overlap between two grids (i.e., integral over the product of the grids). This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grida & 1st grid for integration.\\
cgrid *gridb & 2nd grid for integration.\\
\end{longtable}
\noindent
This function returns the value of the overlap integral (REAL complex).

\subsection{cgrid\_grid\_expectation\_value() -- Grid expectation value}

Calculate the expectation value of a grid over a given probability density: integral(gridb * $|$grida$|^2$). This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grida & 1st grid for integration ($|$grida$|^2$).\\
cgrid *gridb & 2nd grid for integration.\\
\end{longtable}
\noindent
This function returns the value of the overlap integral (REAL complex).

\subsection{cgrid\_grid\_expectation\_value\_func() -- Expectation value of function over grid squared}

Calculate the expectation value of a function over grid squared: int grida func() grida = int func() grida$^2$. This function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
REAL complex (*func)() & Function to be averaged. The arguments to this functions are given below.\\
cgrid *grida & Grid giving the probability density (grida$^2$).\\
\end{longtable}
\noindent
The arguments to (*func)() are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
void *arg & Pointer to use supplied data to the function.\\
REAL complex val & Value of grida at the current point.\\
REAL x & Current value of $x$.\\
REAL y & Current value of $y$.\\
REAL z & Current value of $z$.\\
\end{longtable}
\noindent
This user supplied function return the function value to be averaged (REAL complex). Function cgrid\_grid\_expectation\_value\_func() returns the expectation value (REAL complex).

\subsection{cgrid\_weighted\_integral() -- Integral of grid over weighting function}

Integrate over grid multiplied by weighting function: int grid w(x,y,z). This function takes the arguments as:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be integrated over.\\
REAL complex (*weight)() & Function defining the weight. The arguments to this function are given below.\\
void *farg & Use supplied argument to the weight function.\\
\end{longtable}
\noindent
The weight function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
void *farg & User supplied data to (*weight)().\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
Function rgrid\_weighted\_integral() returns the value of the integral (REAL).

\subsection{cgrid\_weighted\_integral\_of\_square() -- Integral of grid squared over weighting function}

Integrate over grid squared multiplied by weighting function: int grid$^2$ w(x,y,z). This function takes the arguments as:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *grid & Grid to be integrated over.\\
REAL complex (*weight)() & Function defining the weight. The arguments to this function are given below.\\
void *farg & Use supplied argument to the weight function.\\
\end{longtable}
\noindent
The weight function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
void *farg & User supplied data to (*weight)().\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable}
\noindent
Function rgrid\_weighted\_integral\_of\_square() returns the value of the integral (REAL).

\subsection{cgrid\_fd\_gradient\_x() -- Differentiate grid with respect to x}

Differentiate a grid with respect to $x$ (central difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated.\\
cgrid *gradient & Grid containing the derivative (output).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_gradient\_y() -- Differentiate grid with respect to y}

Differentiate a grid with respect to $y$ (central difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated.\\
cgrid *gradient & Grid containing the derivative (output).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_gradient\_z() -- Differentiate grid with respect to z}

Differentiate a grid with respect to $z$ (central difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated.\\
cgrid *gradient & Grid containing the derivative (output).\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_gradient() -- gradient of a grid}

Calculate gradient of a grid (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & grid to be differentiated.\\
cgrid *gradient\_x & $x$ component derivative grid.\\
cgrid *gradient\_y & $y$ component derivative grid.\\
cgrid *gradient\_z & $z$ component derivative grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_laplace() -- Laplace of a grid}

Calculate Laplacian of a grid (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & grid to be differentiated.\\
cgrid *laplace & Grid containing the Laplacian.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_laplace\_x() -- 2nd derivative of a grid (x)}

Calculate 2nd derivative of a grid with respect to $x$ (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & grid to be differentiated.\\
cgrid *laplacex & Grid containing the 2nd derivative.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_laplace\_y() -- 2nd derivative of a grid (y)}

Calculate 2nd derivative of a grid with respect to $y$ (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & grid to be differentiated.\\
cgrid *laplacey & Grid containing the 2nd derivative.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_laplace\_z() -- 2nd derivative of a grid (z)}

Calculate 2nd derivative of a grid with respect to $z$ (finite difference). The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & grid to be differentiated.\\
cgrid *laplacez & Grid containing the 2nd derivative.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fd\_gradient\_dot\_gradient() -- Dot product of gradient of grid with itself}

This function calculates dot product of the gradient of the grid with itself: $\nabla$ grid $\cdot$ $\nabla$ grid (finite difference). It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid  & Source grid for the operation.\\
cgrid *grad\_dot\_grad & Destination grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_print() -- Print contents of grid in ASCII}

This function print a given grid into file in ASCII format. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be printed.\\
FILE *out & Output file pointer.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft() -- Fast forward Fourier transform of grid}

Perform forward Fourier transformation of a grid. The grid for FFT is given as the only argument (cgrid *). The grid is overwritten by the result. No normalization of the output is performed. The function does not return any value. 

\subsection{cgrid\_inverse\_fft() -- Fast inverse Fourier transform of grid}

Perform inverse Fourier transformation of a grid. The grid for FFT is given as the only argument (cgrid *). The function does not return any value.

\subsection{cgrid\_scaled\_inverse\_fft() -- Scaled fast inverse Fourier transform of grid}

Perform scaled inverse Fourier transformation of a grid. The grid for FFT is given as the first argument (cgrid *) followed by normalization constant (i.e., transformed data multiplied by this value). The grid is overwritten by the result. The function does not return any value.

\subsection{cgrid\_inverse\_fft\_norm() -- Normalized fast inverse Fourier transform of grid}

Perform normalized inverse Fourier transformation of a grid. The grid for FFT is given as the only argument (cgrid *). The grid is overwritten by the result. The output is normalized (i.e., doing forward FFT followed by this yields the original data). The function does not return any value.

\subsection{cgrid\_fft\_convolute() -- Convolution in reciprocal space}

Multiply two grids that are in reciprocal space. Convolution between grida and gridb can be obtained by:
\begin{verbatim}
 cgrid_fft(grida);
 cgrid_fft(gridb);
 cgrid_convolute(gridc, grida, gridb);
 cgrid_inverse_fft(gridc);
\end{verbatim}
The output will be in gridc. This function takes three arguments as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grida & 1st grid to be convoluted.\\ 
cgrid *gridb & 2nd grid to be convoluted.\\
cgrid *gridc & Output.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft\_gradient\_x() -- Differentiate grid with respect to $x$ in reciprocal space}

This function differentiates the given grid in the reciprocal (Fourier) space along $x$. It takes the following arguments:                                                                                     
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated (in Fourier space).\\                                                          
cgrid *gradient\_x & Output grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft\_gradient\_y() -- Differentiate grid with respect to $x$ in reciprocal space}

This function differentiates the given grid in the reciprocal (Fourier) space along $x$. It takes the following arguments:                                                                                     
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated (in Fourier space).\\                                                          
cgrid *gradient\_y & Output grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft\_gradient\_z() -- Differentiate grid with respect to $x$ in reciprocal space}

This function differentiates the given grid in the reciprocal (Fourier) space along $x$. It takes the following arguments:                                                                                     
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated (in Fourier space).\\                                                          
cgrid *gradient\_z & Output grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft\_gradient() -- Gradient of grid in reciprocal space}

This function calculates gradient of the given grid in the reciprocal (Fourier) space. It takes the following arguments:                                                                                     
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated (in Fourier space).\\                                                          
cgrid *gradient\_x & Output grid.\\
cgrid *gradient\_y & Output grid.\\
cgrid *gradient\_z & Output grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft\_laplace() -- Laplace of grid in reciprocal space}

This function calculates laplace of the given grid in the reciprocal (Fourier) space. It takes the following arguments:                                                                                     
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be differentiated (in Fourier space).\\                                                          
cgrid *laplace & Output grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_fft\_laplace\_expectation\_value() -- Expectation value of laplace operator in reciprocal space}

This function calculates expectation value of laplace operator in the reciprocal space (i.e., int grid$^*$ grid''). It take arguments as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Source grid for the operation (in reciprocal space; input).\\
cgrid *laplace & Laplacian of the grid (input) (cgrid *; output).\\
\end{longtable}
\noindent
Returns the expectation value (REAL).

\subsection{cgrid\_value\_at\_index() -- Access grid point at given index}

This function returns grid point value at a given index (follows boundary condition). The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be accessed.\\
INT i & Index along $x$.\\
INT j & Index along $y$.\\
INT k & Index along $z$.\\
\end{longtable}
\noindent
This function returns the grid point value (REAL complex). Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{cgrid\_value\_to\_index() -- Set value to grid at given index}

This function puts a specified value to a given index location in a grid. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be accessed.\\
INT i & 1st index ($x$).\\
INT j & 2nd index ($y$).\\
INT k & 3rd index ($z$).\\
REAL complex value & Value to be set at grid location (i, j, k).\\
\end{longtable}
\noindent
This function does not return any value. Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{cgrid\_value() -- Access grid point at (x, y, z)}

This function returns grid point at given (x, y, z) point where linear interpolation is used between the grid points. The arguments are as follows:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be accessed.\\
REAL x & $x$ value.\\
REAL y & $y$ value.\\
REAL z & $z$ value.\\
\end{longtable}
\noindent
This function returns (REAL complex) value at grid position (x, y, z). Note that in CUDA this function is very slow as it transfers every element individually.

\subsection{cgrid\_extrapolate() -- Extrapolate between two grid sizes}

This function extrapolates between grids of different sizes (both size and step) using linear interpolation. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dest & Destination grid.\\
cgrid *src  & Source grid.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{cgrid\_rotate\_z() -- Rotate contents of grid around $z$-axis}

Rotate contents of a grid by a given angle around the $z$-axis. The function takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *in & The original grid (to be rotated).\\                                                                                
cgrid *out & Output grid (rotated grid).\\
REAL th & Rotation angle in radians.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{cgrid\_zero\_re() -- Clear real part of grid}

This function set the real part of every element in a given grid to zero. It takes the grid (cgrid *) as the only argument. This function does not return any value.

\subsection{cgrid\_zero\_im() -- Clear imaginary part of grid}

This function set the imaginary part of every element in a given grid to zero. It takes the grid (cgrid *) as the only argument. This function does not return any value.

\subsection{cgrid\_phase() -- Phase factors of complex grid}

This function extracts the complex phase factors from a given grid. It takes the following arguments:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid dst & Destination grid for the phase factors (real data).\\ 
cgrid src & Source (complex) grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{cgrid\_random() -- Add random noise to grid}

Add random numbers to given grid within [-scale,+scale[ separately to both real and imaginary parts. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid where random numbers will be added.\\
REAL scale & Specify the scale for random numbers.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{cgrid\_poisson() -- Solve Poisson equation}

This routine solves Poisson equation ($\Delta f = u$) subject to periodic boundaries. It
uses finite difference for Laplacian (7 point) and FFT. It takes one grid (rgrid *) as argument, which on entry describes the right hand side function ($u$). On exit, this grid is replaced by the solution ($f$). The function does not return any value.

\subsection{cgrid\_div() -- Divergence of vector field}

Calculate divergence of a given vector field. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *div & Result grid.\\
cgrid *fx  & $x$ component of the vector field.\\
cgrid *fy  & $y$ component of the vector field.\\
cgrid *fz  & $z$ component of the vector field.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{cgrid\_rot() -- Rot of vector field}

Calculate rot of a given vector field. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *rotx & Result grid ($x$ component).\\
cgrid *roty & Result grid ($y$ component).\\
cgrid *rotz & Result grid ($z$ component).\\
cgrid *fx  & $x$ component of the vector field.\\
cgrid *fy  & $y$ component of the vector field.\\
cgrid *fz  & $z$ component of the vector field.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{cgrid\_abs\_rot() -- Norm of rot of vector field}

Calculate norm of rot of a given vector field ($|$rot$|$). The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *rot & Result grid.\\
cgrid *fx  & $x$ component of the vector field.\\
cgrid *fy  & $y$ component of the vector field.\\
cgrid *fz  & $z$ component of the vector field.\\
\end{longtable}
\noindent
This function does not return any value. 

\subsection{cgrid\_zero\_index() -- Zero given range in grid}

Zero a given index range of a complex grid over [lx, hx[ X [ly, hy[ X [lz, hz[. The arguments are:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *grid & Grid to be operated on.\\                                                                           
INT lx & Lower limit for 1st index ($x$).\\                                                                                     
INT hx & Upper limit for 1st index ($x$).\\                                                                                     
INT ly & Lower limit for 2nd index ($y$).\\                                                                                     
INT hy & Upper limit for 2nd index ($y$).\\                                                                                     
INT lz & Lower limit for 3rd index ($z$).\\                                                                                      INT hz & Upper limit for 3rd index ($z$).\\        
\end{longtable}
\noindent
This function has no return value.

\subsection{cgrid\_dealias23() -- Dealias in Fourier space (2/3 rule)}

This function performs de-alias of a grid in Fourier space by the 2/3 rule: zero high wavenumber components between: [n/2 - n/3, n/2 + n/3] in each direction (except the last dimension is [nz - nz/3, nz]). The only argument is the grid (cgrid *; in reciprocal space) that will be operated on. The function does not return any value.

\subsection{cgrid\_ipower() -- Rise grid to integer power}

Raise given grid to a specified integer power (fast -- not using POW()). The following arguments are required:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dst & Destination grid.\\
cgrid *src & Source grid for operation.\\
INT exponent & Exponent to be used. This value can be negative.\\
\end{longtable}
\noindent
This function does not return any value. 

\section{Mixed real - complex grid routines}

\subsection{grid\_read\_peek() -- Peek at file for dimensions}

This function takes a peek at the specified grid file to get the grid dimensions. It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
FILE *fp & File pointer for operation.\\                                                                                   
INT *nx & Number of points along $x$-axis (1st index).\\
INT *ny & Number of points along $y$-axis (2nd index).\\
INT *nz & Number of points along $z$-axis (INT *; input).\\
REAL *step & Spatial grid step length.\\
\end{longtable}
\noindent
The function does not return any value (all data is returned through the above pointers). This function works with both REAL and REAL complex grids. After reading the dimensions, the file pointer (*fp) is rewound so that Xgrid\_read() and be called subsequently.

\subsection{grid\_real\_to\_complex\_re() -- Copy real grid to real part of complex grid}

Copy a real grid to real part of a complex grid (imaginary part is set to zero). The following arguments apply:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dest & Destination grid.\\
rgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_real\_to\_complex\_im() -- Copy real grid to imaginary part of complex grid}

Copy a real grid to imaginary part of a complex grid (real part is set to zero). The following arguments apply:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dest & Destination grid.\\
rgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_add\_real\_to\_complex\_re() -- add real grid to real part of complex grid}

Add a real grid to real part of a complex grid (imaginary part unchanged). The following arguments apply:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dest & Destination grid.\\
rgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_add\_real\_to\_complex\_im() -- add real grid to imaginary part of complex grid}

Add a real grid to imaginary part of a complex grid (real part unchanged). The following arguments apply:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dest & Destination grid.\\
rgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_product\_complex\_with\_real() -- Product of real grid with complex grid}

Calculates product of a real grid with a complex grid: dest(complex) = dest(complex) * source(real). The following arguments apply:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
cgrid *dest & Destination grid.\\
rgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_complex\_im\_to\_real() -- Copy imaginary part to real grid}

Copy imaginary part of a complex grid to real grid. The arguments are the source and destination grids:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *dest & Destination grid.\\
cgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_complex\_re\_to\_real() -- Copy real part to real grid}

Copy real part of a complex grid to real grid. The arguments are the source and destination grids:
\begin{longtable}{p{.25\textwidth} p{.65\textwidth}}
Argument & Description\\
\cline{1-2}
rgrid *dest & Destination grid.\\
cgrid *source & Source grid.\\
\end{longtable}
\noindent
This function does not return any value.

\section{Common routines to all grid types}

\subsection{grid\_fft\_read\_wisdom() -- Read FFTW wisdom file}

This routine will read FFTW wisdom file from disk. Wisdom files contain predetermined information about the current system, which helps provide the fastest FFT implementation (and avoids the initial tuning step). It takes one argument, which specifies the wisdom file name (char *). If this is a NULL pointer, the default file name will be used (fftw-hostname.wis). This function does not return any value.

\subsection{grid\_fft\_write\_wisdom() -- Write FFTW wisdom file}

This routine will write FFTW wisdom file to disk. Wisdom files contain predetermined information about the current system, which helps provide the fastest FFT implementation (and avoids the initial tuning step).  It takes one argument, which specifies the wisdom file name (char *). If this is a NULL pointer, the default file name will be used (fftw-hostname.wis). This function does not return any value.

\section{Wave function routines}

The following routines act on wave functions (wf data type).

\subsection{grid\_wf\_alloc() -- Allocate wave function}

This function will allocate wave function (including the grid holding the data). It takes the following arguments:
\begin{longtable}{p{.2\textwidth} p{.7\textwidth}}
Argument & Description\\
\cline{1-2}
INT nx & Number of spatial grid points along $x$ (1st index).\\
INT ny & Number of spatial grid points along $y$ (2nd index).\\
INT nz & Number of spatial grid points along $z$ (3rd index).\\
REAL step & Spatial step size for wave function grid.\\
REAL mass & Mass of the particle corresponding to this wave function (in atomic units).\\
char boundary & Boundary condition for wave function: WF\_DIRICHLET\_BOUNDARY = Dirichlet boundary condition, WF\_NEUMANN\_BOUNDARY = Neumann boundary condition, WF\_PERIODIC\_BOUNDARY = Periodic boundary condition.\\
char propagator & Which time propagator to use for this wave function: WF\_2ND\_ORDER\_PROPAGATOR = 2nd order in time, WF\_4TH\_ORDER\_PROPAGATOR = 4th order in time.\\
char *id & String identifier describing the grid (for debugging; char *; input).
\end{longtable}
\noindent
This function returns a pointer to the allocated wave function structure (wf *). If memory allocation fails, NULL is returned.

\subsection{grid\_wf\_free() -- Free wave function}

This function frees a given wave function. The only argument is a pointer to the wave function structure (wf *). Function has no return value.

\subsection{grid\_wf\_absorb() -- Complex time for absorbing boundaries}

Calculate (complex) time for implementing absorbing boundaries using mixed real/imaginary time propagation. Excitations entering the absorbing region will be damped out
such that no back reflections occur from the boundary of the finite grid.
This is achieved by introducing imaginary time component to propagation
in this reagion, which is turned to full gradually (using a linear function).
This is to be used with time propagation routines that allow spatially dependent
time (kinetic energy propagation by FFT cannot be used). The absorging region is placed outside [lx,hx] x [ly,hy] x [lz,hz]. At the corners of the box, the propagation time
is (1.0 - I) * tstep (whereas outside the absorbing region the imaginary
component is zero). Each x,y,z direction contributes 1/3 to the imaginary component.
The arguments are as follows:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT i & Current index along $x$ (1st).\\                                                                                    
INT j & Current index along $y$ (2nd).\\
INT k & Current index along $z$ (3rd).\\
void *data & Pointer to struct grid\_abs holding values for specifying the absorbing region. This will specify amp (attenuation amplitude), lx (lower index for $x$), hx (upper index for $x$), ly (lower index for $y$), hy (upper index for $x$), lz (lower index for $z$), hz (upper index for $z$).\\
REAL complex time\_step & Real time step to be used.\\
\end{longtable}
\noindent
This function returns complex time step to be used at (i, j, k) (REAL complex). The grid\_abs structure is:
\begin{verbatim}
struct grid_abs {
  REAL amp;           /* Absorption amplitude (larger means higher absorption) */
  INT data[6];        /* Six indices corresponding to lx, hx, ly, hy, lz, hz */
};
\end{verbatim}

\subsection{grid\_wf\_velocity() -- Calculate velocity field}

Calculate the velocity field (from gradient of the complex phase) associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *vx & $x$ component of the velocity field.\\
rgrid *vy & $y$ component of the velocity field.\\
rgrid *vz & $z$ component of the velocity field.\\
REAL cutoff & Cutoff value for velocity ($|v| <=$ cutoff) as the phase may not be well defined where the norm of the wave function is small.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_velocity\_x() -- Calculate $x$ component of velocity field}

Calculate $x$ component of the velocity field (from gradient of the complex phase) associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *vx & $x$ component of the velocity field.\\
REAL cutoff & Cutoff value for velocity ($|v| <=$ cutoff) as the phase may not be well defined where the norm of the wave function is small.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_velocity\_y() -- Calculate $y$ component of velocity field}

Calculate $y$ component of the velocity field (from gradient of the complex phase) associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *vy & $y$ component of the velocity field.\\
REAL cutoff & Cutoff value for velocity ($|v| <=$ cutoff) as the phase may not be well defined where the norm of the wave function is small.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_velocity\_z() -- Calculate $z$ component of velocity field}

Calculate $z$ component of the velocity field (from gradient of the complex phase) associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *vz & $z$ component of the velocity field.\\
REAL cutoff & Cutoff value for velocity ($|v| <=$ cutoff) as the phase may not be well defined where the norm of the wave function is small.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_probability\_flux() -- Calculate probability flux}

Calculate the probability flux associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *flux\_x & $x$ component of the flux.\\
rgrid *flux\_y & $y$ component of the flux.\\
rgrid *flux\_z & $z$ component of the flux.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_probability\_flux\_x() -- Calculate probability flux $x$ component}

Calculate the $x$ component of probability flux associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *flux\_x & $x$ component of the flux.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_probability\_flux\_y() -- Calculate probability flux $y$ component}

Calculate the $y$ component of probability flux associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *flux\_y & $y$ component of the flux.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_probability\_flux\_z() -- Calculate probability flux $z$ component}

Calculate the $z$ component of probability flux associated with the wave function. The arguments to this function are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the operation.\\
rgrid *flux\_z & $z$ component of the flux.\\
\end{longtable}
\noindent
This function has no return value.

\subsection{grid\_wf\_energy() -- Total energy of wave function}

Calculate the total energy (kinetic + potential) for the wave function. This includes also the energy of the possible moving background. The arguments are as follows:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the energy calculation.\\
cgrid *potential & Grid containing the potential function.\\
cgrid *workspace & Additional storage needed for the operation.\\
\end{longtable}
\noindent
This function returns the total energy (REAL).

\subsection{grid\_wf\_potential\_energy() -- Calculate potential energy}

This function calculates the potential energy of a given wave function. The arguments are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the potential energy calculation.\\
cgrid *potential & Grid containing the potential function.\\
\end{longtable}
\noindent
This function returns the potential energy (REAL).

\subsection{grid\_wf\_propagate() -- Propagate wave function in time}

Propagate the wave function in time subject to a given potential. The arguments are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function to be propagated.\\
cgrid *potential & Grid containing the (complex) potential.\\
cgrid *sq\_grad\_pot & grid containing square of potential gradient. Only used for the 4th order propagator (can be set to NULL when not used).\\
REAL complex time & Time step for propagation (atomic units). Note this may be complex.\\
cgrid *workspace & Additional workspace needed for the operation.\\
\end{longtable}
\noindent
This function returns no value.

\subsection{grid\_wf\_propagate\_potential() -- Propagate wave function in time (potential only)}

Propagate wave function in time using potential only. The arguments are as follows:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function to be propagated.\\
REAL complex (*time)() & Time step function. If NULL, constant value will be used specified by tstep below.\\
REAL complex *tstep & Time step (atomic units).\\
void *privdata & Private data for the time step function.\\                                                                            
cgrid *potential & Grid containing the potential.\\
\end{longtable}
\noindent
Function grid\_wf\_propagate\_potential() does not return any value. The time step function REAL complex (*time)(), which allows spatial variation in time stepping, takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT i & 1st grid point index ($x$).\\
INT j & 2nd grid point index ($y$).\\
INT k & 3rd grid point index ($z$).\\
void *privdata & Pointer to user supplied private data.\\
REAL complex tstep & Value of tstep passed to grid\_wf\_propagate\_potential().\\
\end{longtable}
\noindent
The function returns the (complex) time step to be used for grid point (i, j, k).

\subsection{grid\_wf\_density() -- Compute probability density for wave function}

This function computes the probability density ($|\psi|^2$) for the given wave function. It takes two arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function for the density calculation.\\
rgrid *density & Density grid output.\\
\end{longtable}
\noindent
This function does not return any value.

\subsection{grid\_wf\_zero() - Zero wave function}

Set all values in the grid describing the wave function to zero. It takes a pointer to the wave function as the only argument (wf *). It does not return any value.

\subsection{grid\_wf\_constant() - Set wave function to constant value}

Set all values in the grid describing the wave function to a given value. It takes a pointer to the wave function as the first argument (wf *) and the second argument is the constant value (REAL complex). It does not return any value.

\subsection{grid\_wf\_map() -- Map function on wave function grid}

This routine maps a given function to the complex grid of a wave function. The arguments are:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
wf *gwf & Wave function on which the function will be mapped to.\\
REAL complex (*func)() & Function providing the mapping (see below).\\
void *farg & Optional argument for passing private data to func (NULL if not needed).\\
\end{longtable}
\noindent
Function grid\_wf\_map() does not return any value. Function REAL complex (*func)() takes the arguments as:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
void *farg & Private data for the function.\\
REAL x & Current $x$ coordinate.\\
REAL y & Current $y$ coordinate.\\
REAL z & Current $z$ coordinate.\\
\end{longtable} 
\noindent
The return value (REAL complex) is the function value at the current point.

\subsection{grid\_wf\_norm() -- Calculate norm of wave function}

This function returns (REAL) the norm ($\int|\psi|^2d\tau$) of the wave function, which is specified by the argument to this function (wf *).

\subsection{grid\_wf\_normalize() -- Normalize wave function}

This function normalizes the given wave function (i.e., impose $\int|\psi|^2d\tau = 1$). The argument to this function (wf *) specifies the wave function. The return value (REAL) is the previous norm of the wave function prior to normalization.

\subsection{grid\_wf\_overlap() -- Overlap integral between wave functions}

Calculate the overlap integral between two wave functions (i.e., $\int \psi_1^*\psi_2d\tau$). This function takes the two wave functions (wf *) as arguments and returns the overlap (REAL complex).

\subsection{grid\_wf\_print() -- Print wave function}

This function returns prints the values of the grid points in the wave function using cgrid\_print(). It takes the wave function (wf *) as the first argument and file pointer (FILE *) as the second argument (these are same as for cgrid\_print()). This function does not return any value.

\section{Linear algebra routines}

Routines for solving matrix equation problems for specialized cases are provided. These include various tridiagonal systems that arise from finite difference discretization of the Laplace operator. Only the externally usable functions are described below.

\subsection{grid\_solve\_tridiagonal\_system() -- Solve tridiagonal $Ax = b$ problem}

Solve tridiagonal matrix equation $Ax = b$ by using the Thomas algorithm. This algorithm is not stable in general but works for diagonally dominant systems. It takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT *n & dimensionality (number of equations).\\
REAL complex *a & Subdiagonal of $A$ (preserved) (indexed 1 ... n-1). Element 0 unused.\\
REAL complex *b & Diagonal of $A$ (overwritten).\\
REAL complex *c & Supdiagonal of $A$ (preserved) (indexed 0 ... n-2). Element n-1 unused.\\
REAL complex *v & Right-hand side vector $b$ (overwritten).\\
REAL complex *x & Solution on exit.\\
INT str & Stride for writing the output (if elements of solution are not located adjacent to each other in memory).\\
\end{longtable}
\noindent
Note that a and x may be the same array. This function does not return any value.

\subsection{grid\_solve\_tridiagonal\_system\_cyclic() -- Solve tridiagonal $Ax = b$ problem (Sherman-Morrison)}

Solve tridiagonal matrix equation $Ax = b$ by using the Sherman-Morrison/Thomas algorithm. Below alpha and beta specify the extreme non-zero elements in $A$ (this may arise, for example, from finite difference and periodic boundary condition. The arguments to this function are as follows:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
INT n & Dimensionality (number of equations).\\
REAL complex *a & Subdiagonal of $A$ (indexed 1 ... n-1). Element 0 unused.\\
REAL complex *b & Diagonal of $A$ (overwritten).\\
REAL complex *c & Supdiagonal of $A$ (indexed 0 ... n-2). Element n-1 unused.\\
REAL complex *v & Right hand side vector $b$ (overwritten).\\
REAL complex alpha & Left corner matrix element for the last row of $A$.\\
REAL complex beta  & Right corner matrix element for the first row of $A$.\\
REAL complex *x & Solution on exit.\\
INT str & Stride; solution $x$ may go to a non-continuous array.\\
REAL complex *bb & Worksapce vector of dimension n.\\
\end{longtable}
\noindent
This function has no return value.

\section{Interpolation}

This section describes miscellaneous functions in libgrid.

\subsection{grid\_polynomial\_interpolate() - Polynomial interpolation}

This function performs polynomial interpolation over a discrete set of (x, y) values. It takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *xa & Array of discrete $x$ values.\\
REAL *ya & Array of discrete $y$ values.\\  
INT n & Number of (x,y) points in the above arrays.\\
REAL *x & Point at which the approximation is sought.\\
REAL *dy & Returned error estimate.\\
\end{longtable}
\noindent
Estimate of the function at point $x$ is returned (REAL).

\subsection{grid\_spline\_ypp() and grid\_spline\_interpolate() -- Spline interpolation}

These functions perform spline interpolation of discrete data points. User must first call function grid\_spline\_ypp() once (2nd derivative calculation) after which grid\_spline\_interpolate() can be called multiple times to obtain the spline approximation. Function grid\_spline\_ypp() takes the following arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *x & Array of $x$ values.\\
REAL *y & Array of $y$ values.\\
INT n & Number of (x,y) points.\\
REAL yp1 & First derivative at point x[1].\\
REAL ypn & First derivative at point x[n+1].\\
REAL *y2 & Storage for second derivative (computed; dimension n).\\
\end{longtable}
\noindent
This function does not return any value. After grid\_spline\_upp() function has been called, grid\_spline\_interpolate() can be called with arguments:
\begin{longtable}{p{.3\textwidth} p{.6\textwidth}}
Argument & Description\\
\cline{1-2}
REAL *xa & Array of $x$ values.\\
REAL *ya & Array of $y$ values.\\
REAL *y2a & Array of second derivatives (computed in grid\_spline\_ypp()).\\
INT n & Number of (x,y) points.\\
REAL x & Point at which the approximation is obtained.\\
\end{longtable}
\noindent
This function returns the spline approximation at point $x$.

\chapter{Parallel execution}

libgrid supports parallel execution with both OpenMP (requires shared memory computer) or CUDA (NVIDIA GPUs). On systems with both OpenMP and CUDA available, it can employ both simultaneously without any additional input from the user. For most operations GPUs are much faster than traditional CPUs and therefore libgrid will try to do most computations on the GPU (within the limited memory available on them). Both parallel schemes require their own initialization function call as explained below. A program written to use libgrid usually does not need any additional modification to run on GPUs. The main limitation with GPUs is the amount of memory available and, if user attempts to use more memory than is available, some of the operations may have to run on the CPU (where more memory is available).

\section{OpenMP specific routines}

OpenMP execution employs threads, which show as only one process in ps/top utilities. However, both of them will show 100\% times the number of threads occupation (e.g., 6 threads will result in 600\% CPU usage).

\subsection{grid\_threads\_init() -- Initialize OpenMP threads}

To initialize OpenMP threads, the user code should always call first this function. It takes one argument that specifies how many threads will be used (INT). For maximum performance, this should be very close to the number of CPU cores available on the system. This function does not return any value. Using a value of zero for the number of threads will use the same number threads as the system has available cores.

\subsection{grid\_threads() -- Return number of OpenMP threads in use}

This function returns the current OpenMP threads in use (INT). This function does not take any arguments.

\subsection{grid\_set\_fftw\_flags() -- Set FFT planning flags for FFTW}

Set FFTW specific planning flags (see FFTW documentation). FFTW has many different FFT algorithms implemented and the planning stage will determine (at run time) which of these is fastest for the current system. This function takes one argument that specifies the planning method (char). The following values are possible 0 = Estimate (fast), 1 = Measure (fast; default), 2 = Patient (very slow), 3 = Exhaustive (even slower). The best performance is obtained with modes 2 and 3. This function does not return any value.

\subsection{grid\_get\_fftw\_flags() -- Return current FFTW planning flags}

This function returns the current FFTW planning flags in use (char). This function does not take any arguments.

\section{CUDA specific routines}

To enable CUDA parallel execution in libgrid, function cuda\_enable() must be called with argument 1 (= enable) first. Once enabled, libgrid will automatically schedule grid operations to CPU or GPU depending on where the grids are currently stored. Libgrid has its own memory management system for keeping track which grids are on CPU and which on GPU. Although this system is more or less invisible to the user, some of its inner details are documented in the following. The GPU memory (which is independent of the CPU memory) is allocated in blocks (usually one block = one grid), which are described by the following structure:
\begin{verbatim}
struct gpu_mem_block {
  void *gpu_mem;             /* GPU memory pointer */
  void *host_mem;            /* Corresponding host memory pointer */
  size_t length;             /* Memory block length */
  time_t created;            /* time(0) value of block creation */
  time_t last_used;          /* time(0) value of last access */
  long access_count;         /* How many times has the data been accessed */
  char locked;               /* Page locked in GPU memory? (1 = yes, 0 = no) */
  char id[32];               /* String ID describing the block */
  struct gpu_mem_block *next;/* Next block in linked list (NULL terminated list) */
}; 
typedef struct gpu_mem_block gpu_mem_block;
\end{verbatim}
The block statistics (creation time, last used, data access count) is used to decide where it is most beneficial to store the grid (CPU or GPU). Memory pointers *gpu\_mem and *host\_mem point to the data stored in GPU/CPU. Setting locked flag will prevent the memory block from being swapped out to the CPU memory (cuda\_lock\_block() and cuda\_unlock\_block() functions). String id can be set by the user to describe the contents of the memory block (useful for debugging). The last entry in the structure is a link to the next memory block. Libgrid keeps track of the memory blocks using a linked list.

Grid operations are divided into one, two, three, and four grid operations. Each of these has its own policy for GPU execution. In addition, FFT and memory copy operations have their own one grid policies. Currently, these policies are as follows:\\

\begin{longtable}{p{.1\textwidth} p{.8\textwidth}}
Policy & Description\\
\cline{1-2}
FFT & Execute FFT on the GPU always (even when other blocks have to be swapped out).\\
One &  1. Execute the operation on the GPU if there is enough memory left.\\
    &  2. If the block is alreay on GPU run the operation there.\\
    &  3. If the block is not on GPU and there is not enough memory left, run on the host (CPU).\\
Two & 1. Execute the operation on the GPU if there is enough memory available for both blocks.\\
    & 2. If one of the blocks is already on GPU run the operation there.\\
    & 3. If neither block is on GPU and there is not enough memory left, run on the host (CPU).\\
Three & 1. Execute the operation on the GPU if there is enough memory left for all three blocks.\\
      & 2. If at least two of the blocks are already on GPU run the operation there.\\
      & 3. If none of the blocks are on GPU and there is not enough memory left, run on the host (CPU).\\
Four & 1. Execute the operation on the GPU if there is enough memory left for all four blocks.\\
     & 2. If at least two of the blocks are already on GPU run the operation there.\\     
     & 3. If none of the blocks are on GPU and there is not enough memory left, run on the host (CPU).\\
Copy & 1. Execute the operation on the GPU if there is enough memory left for both blocks. The subsequent ops will be likely on GPU.\\
     & 2. If the source block is already on GPU run the operation there.\\
     & 3. If none of the blocks are on GPU and there is not enough memory left, run on the host (CPU).\\
\end{longtable}
\noindent
These policies can be modified by changing libgrid/src/cuda.c source file (functions cuda\_*\_policy()). Libgrid calls these policy functions automatically and there is no need for the user to call them. Since memory transfers between CPU and GPU memory are very slow, it is important to have good policies for the execution of the grid operations. Simple statistics of the running CUDA processes can be obtained with nvidia-smi command. The important numbers are the Volatile GPU utilization as well as the power consumption. The old wisdom: ``Tune for maximum smoke" seems to work fairly well. This means that the higher the GPU power consumption, the faster the program usually runs. The GPU utilization does not appear to be as meaningful indication of the GPU efficiency. For more accurate profiling, use the CUDA profiler (nvprof).

Below only the functions that user level libgrid programs may have to call are documented. There are many other functions (e.g., memory block allocation, free, etc.) that are internally used by libgrid. They are also available for users to call, but one must know exactly what to do with them... (should not be needed). Most things are taken care of automatically by libgrid.

\subsection{cuda\_enable() -- Enable CUDA execution}

This function enables (argument value 1) or disables (argument value 0) CUDA execution (argument type char). In order to enable CUDA, this function must be called first with argument 1. No value is returned.

\subsection{cuda\_set\_gpu() -- Set GPU for CUDA execution (multi-GPU systems only)}

This function sets the default CUDA GPU to use. This is specified by the only argument to this function (int). The first GPU is 0, 2nd is 1, etc. This function does not return any value.

\subsection{cuda\_error\_check() -- Perform CUDA error check (slow)}

This will perform CUDA error checking, which is not done by default as it slows down the execution. It will call abort() if something is wrong, so that the stack trace can be used to locate the problem. Users do not usually need to use this function. It has no return value.

\subsection{cuda\_memory() -- Return amount of free GPU memory}

This function returns the currently available GPU memory in bytes (size\_t). It takes no arguments. Libgrid monitors the memory usage automatically and swaps in/out memory blocks as needed.

\subsection{cuda\_statistics() -- Print CUDA memory block statistics}

This function prints CUDA memory block allocation statistics. It takes one argument (char), which controls the output: 0 = print only summary or 1 = print also individual GPU memory block information. This function does not return any value.

\subsection{cuda\_gpu\_info() -- Print GPU information}

This function prints the current GPU information (card model, amount of memory, etc.). It takes no arguments and does not return any value.

\chapter{Interfacing with other software}

\section{External functions}

Users may wish to provide their own functions that operate on grids, which causes a problem for CUDA execution. CUDA wants the functions to be compiled separately using nvcc compiler, which would require libgrid users to consider CUDA coding \& compilation. To work around this inconvenience, libgrid allows users to define their on functions (libgrid/src/ext-cuda directory). These are compiled at the time of libgrid compilation, which also makes them accessible in CUDA. Currently, there are several functions defined using this external mechanism, which are used by libdft library. See libgrid/src/ext-cuda directory for examples.

\section{Utilities}

Several utilities are available for converting the libgrid binary grid format to other formats that can be read by 3rd party visualization programs (e.g., visit, paraview, xmgrace, veusz). These programs are located in libgrid/util directory. They have to be compiled and installed separately (i.e., make and make install in that directory). The default installation directory is /usr/local/bin. All NETCDF files created will have x, y, and z fields that describe the grid dimensions.

\subsection{grd2cdf -- Convert libgrid format to NETCDF}

To convert test.grd (created by libgrid) to NETCDF format, use:
\begin{verbatim}
% grd2cdf test.grd test.cdf
\end{verbatim}

\subsection{vector2cdf -- Convert scalar and vector field to NETCDF}

Convert one scalar and one vector field to one NETCDF file. For example:
\begin{verbatim}
% vector2cdf density.grd flux_x.grd flux_y.grd flux_z.grd cdffile.cdf
\end{verbatim}
where density.grd is a scalar grid and flux\_x, flux\_y, flux\_z correspond to $x$, $y$, $z$ components of the field. All these will be separately accessible in the NETCDF file and they can be overlaid in graphics presentation. To visualize a vector field in visit, it must first be converted (vecfield is the vector field name):
\begin{enumerate}
\item Select Controls $\rightarrow$ Expressions
\item Enter name: vecfield
\item Type: Vector Mesh Variable
\item Standard Editor: $\lbrace$fx,fy,fz$\rbrace$
\item Press Apply.
\end{enumerate}

\subsection{wf2cdf -- Convert libgrid binary wave function to NETCDF (scalar \& vector field)}

Convert wave function grid to NETCDF file containing: density ($|\psi|^2$) and the three probability flux components: flux\_x, flux\_y, flux\_z. This file can be visualized with visit (see above) or with paraview. In the latter case make sure that the NETCDF file has the extension ``.nc" (rather than ``.cdf"). The fields in NETCDF file are: rho = density, fx = flux\_x, fy = flux\_y, and fz = flux\_z. For example, to convert wave function grid file, use:
\begin{verbatim}
% wf2cdf wavefunction.grd wavefunction.nc
\end{verbatim}

\subsection{wf2cdf2 -- Convert libgrid binary wave function to NETCDF (real \& imaginary parts)}

Similar to wf2cdf but only place real and imaginary parts of the wave function into the NETCDF file (field names re and im). 

\subsection{gview and gview2 -- Animate 1-D data using xmgrace program}

Both gview and gview2 programs will take an ordered list of files as arguments, which will be displayed in that order. There is a short pause at the first file to allow adjustment of the display. View works for ASCII files of 3-D cuts along x, y, and z axes (as output by rgrid\_write\_grid()). View2 works for 1-D grids (e.g., dimension 1, 1, 256). To animate a set of files bubble-*.z (1-D), use:
\begin{verbatim}
% gview2 bubble-{?,??,???,????,?????}.z
\end{verbatim}
where the files were named bubble-1.z, bubble-2.z, etc. The wildcard above (csh/tcsh syntax; bash is likely different) ensures that the files will appear in the correct order. View2 also allows saving the individual images during view. To get this behavior, add -s option. Programs like ffmpeg can be used to create movies from the resulting jpg files.

\chapter{Examples}

\section{Fourier transform example}

\begin{verbatim}
/*
 * Example: FFT of real grid.
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <grid/grid.h>
#include <omp.h>

/* Grid dimensions */
#define NX 256
#define NY 256
#define NZ 256

/* Spatial step length of the grid */
#define STEP 0.5

/* wave vectors top be mapped onto grid */
#define KX 1.0
#define KY 1.0
#define KZ 1.0

/* Function returning standing wave in x, y, and z directions */
REAL func(void *NA, REAL x, REAL y, REAL z) {

  return COS(x * 2.0 * M_PI * KX / (NX * STEP)) 
        + COS(y * 2.0 * M_PI * KY / (NY * STEP)) 
        + COS(z * 2.0 * M_PI * KZ / (NZ * STEP));
}

int main(int argc, char **argv) {

  rgrid *grid;           /* Pointer real grid structure */

  grid_threads_init(0);  /* Use all available cores */

  /* If libgrid was compiled with CUDA support, enable CUDA */
#ifdef USE_CUDA
  cuda_enable(1);
#endif

  /* Allocate real grid with dimensions NX, NY, NZ and spatial step size STEP */
  /* Periodic boundary condition is assigned to the grid */
  grid = rgrid_alloc(NX, NY, NZ, STEP, RGRID_PERIODIC_BOUNDARY, NULL, "test grid");

  /* Map the standing wave function onto the grid */
  rgrid_map(grid, &func, NULL);

  /* Output the grid before FFT */
  rgrid_write_grid("before", grid);

  /* Perform FFT */
  rgrid_fft(grid);

  /* Perform normalize inverse FFT */
  rgrid_inverse_fft_norm(grid);

  /* Write grid after forward & inverse FFTs (we should get the original grid) */
  rgrid_write_grid("after", grid);

  /* If CUDA in use, output usage statistics */
#ifdef USE_CUDA
  cuda_statistics(1);
#endif

  return 0;
}
\end{verbatim}

\section{Spherical average example}

\begin{verbatim}
/*
 * Example: Calculate spherical average of a real grid.
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <grid/grid.h>
#include <omp.h>

/* Grid dimensions */
#define NX 256
#define NY 256
#define NZ 256

/* Spatial step length of the grid */
#define STEP 0.5

/* Binning info */
#define BINSTEP 0.5
#define NBINS (NX / 2)
/* 0 = Calculate spherical average, 1 = Include multiplication by 4pi r^2 */
#define VOLEL 0   

/* Function to be mapped onto the grid */
REAL func(void *NA, REAL x, REAL y, REAL z) {

  return x * x + y * y + z * z;
}

int main(int argc, char **argv) {

  rgrid *grid;
  REAL *bins;
  FILE *fp;
  INT i;
 
  /* Initialize threads (0 = use all threads available) */
  grid_threads_init(0);

  /* If libgrid was compiled with CUDA support, enable CUDA */
#ifdef USE_CUDA
  cuda_enable(1);
#endif
  
  /* Allocate real grid */
  grid = rgrid_alloc(NX, NY, NZ, STEP, RGRID_PERIODIC_BOUNDARY, NULL, "test grid");

  /* Map function func() onto the grid */
  rgrid_map(grid, &func, NULL);

  /* Write the data on disk before starting */
  rgrid_write_grid("before", grid);

  /* Allocate memory for the bins */
  bins = (REAL *) malloc(sizeof(REAL) * NBINS);
  /* Perform spherical average of the grid */
  rgrid_spherical_average(grid, NULL, NULL, bins, BINSTEP, NBINS, VOLEL);

  /* Write spherical average to disk */
  if(!(fp = fopen("after.dat", "w"))) {
    fprintf(stderr, "Can't open file for writing.\n");
    exit(1);
  }
  for (i = 0; i < NBINS; i++)
    fprintf(fp, FMT_R " " FMT_R "\n", BINSTEP * (REAL) i, bins[i]);
  fclose(fp);

  return 0;
}
\end{verbatim}

\section{Poisson equation example}

\begin{verbatim}
/*
 * Example: Solve Poisson equation.
 *
 */

#include <stdio.h>
#include <math.h>
#include <grid/grid.h>

/* Grid dimensions */
#define NX 256
#define NY 256
#define NZ 256
#define STEP 0.2

/* Right hand side function for Poisson equation (Gaussian) */
REAL gaussian(void *arg, REAL x, REAL y, REAL z) {

  REAL inv_width = 0.2;
  REAL norm = 0.5 * M_2_SQRTPI * inv_width;

  norm = norm * norm * norm;
  return norm * exp(-(x * x + y * y + z * z) * inv_width * inv_width);
}

int main(int argc, char **argv) {
  
  rgrid *grid, *grid2;
  
  /* Initialize with 16 OpenMP threads */
  grid_threads_init(16);

  /* If libgrid was compiled with CUDA support, enable CUDA */
#ifdef USE_CUDA
  cuda_enable(1);
#endif
  
  /* Allocate real grid for the right hand side (and the solution) */
  grid = rgrid_alloc(NX, NY, NZ, STEP, RGRID_PERIODIC_BOUNDARY, NULL, "Poisson1");
  grid2 = rgrid_alloc(NX, NY, NZ, STEP, RGRID_PERIODIC_BOUNDARY, NULL, "Poisson2");

  /* Map the right hand side to the grid */
  rgrid_map(grid, gaussian, NULL);

  /* Write right hand side grid */
  rgrid_write_grid("input", grid);

  /* Solve the Poisson equation (result written over the right hand side in grid) */
  rgrid_poisson(grid);  

  /* Write output file (solution) */
  rgrid_write_grid("output", grid);

  /* Check by taking Laplacian (should be equal to input) & write */
  rgrid_fd_laplace(grid, grid2);
  rgrid_write_grid("check", grid2);

  return 0;
}
\end{verbatim}

\section{Wave packet example}

\begin{verbatim}
/*
 * Example: Propagate wavepacket in harmonic potential (3D).
 *
 * Try for example:
 * ./wavepacket 0 128 0.01 200 0.0 0.0 0.0 0.25 0.25 0.25 -2.0 0.0 0.0
 *
 * Although this is 3-D calculation, the above settings will initiate
 * the motion along the x-axis. Therefore it can be visualized by:
 *
 * gview2 output-{?,??,???}.x
 * 
 * (the wildcard syntax is likely different for bash; the above is tcsh)
 *
 * Arguments:
 * 1st  = Number of threads to be used.
 * 2nd  = Number of points in X, Y, Z directions (N x N x N grid).
 * 3rd  = Time step (atomic units).
 * 4th  = Number of iterations to run.
 * 5th  = Initial wave vector (momentum) along X (atomic units).
 * 6th  = Initial wave vector (momentum) along Y (atomic units).
 * 7th  = Initial wave vector (momentum) along Z (atomic units).
 * 8th  = Initial wave packet width in X direction (atomic units).
 * 9th  = Initial wave packet width in Y direction (atomic units).
 * 10th = Initial wave packet width in Z direction (atomic units).
 * 11th = Initial wave packet center along X direction (atomic units).
 * 12th = Initial wave packet center along Y direction (atomic units).
 * 13th = Initial wave packet center along Z direction (atomic units).
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <grid/grid.h>
#include <omp.h>

/* Define this for 4th order accuracy in time */
/* Otherwise for 2nd order accuracy */
#define FOURTH_ORDER_PROPAGATOR

REAL complex wavepacket(void *arg, REAL x, REAL y, REAL z);
REAL complex harmonic(void *arg, REAL x, REAL y, REAL z);

/* Wave packet structure */
typedef struct wparams_struct {
  REAL kx, ky, kz;
  REAL wx, wy, wz;
  REAL xc, yc, zc;
} wparams;

/* Harmonic potential parameters */
typedef struct pparams_struct {
  REAL kx, ky, kz;
} pparams;

int main(int argc, char *argv[]) {

  INT l, n, iterations, threads;
  REAL step, lx, time_step;
  REAL complex time;
  wf *gwf = NULL;
  cgrid *potential, *workspace, *workspace2;
#ifdef FOURTH_ORDER_PROPAGATOR
  cgrid *sq_grad_pot;
#endif
  rgrid *rworkspace;
  char fname[256];
  pparams potential_params;
  wparams wp_params;
  
  /* Parameter check */
  if (argc != 14) {
    fprintf(stderr, "Usage: wavepacket <thr> <npts> <tstep> <iters> <kx> <ky> <kz> <wx> <wy> <wz> <xc> <yc> <zc>\n", argv[0]);
    return -1;
  }
  
  /* Parse command line arguments */
  threads = atoi(argv[1]);
  n = atoi(argv[2]);
  time_step = atof(argv[3]);
  iterations = atol(argv[4]);
  wp_params.kx = atof(argv[5]);
  wp_params.ky = atof(argv[6]);
  wp_params.kz = atof(argv[7]);
  wp_params.wx = atof(argv[8]);
  wp_params.wy = atof(argv[9]);
  wp_params.wz = atof(argv[10]);
  wp_params.xc = atof(argv[11]);
  wp_params.yc = atof(argv[12]);
  wp_params.zc = atof(argv[13]);

  if(wp_params.wx == 0.0 || wp_params.wy == 0.0 || wp_params.wz == 0.0) {
    fprintf(stderr, "Width cannot be zero.\n");
    exit(1);
  }
  
  /* Set spatial grid step length based on number of grid points */
  step = 0.4 / (((REAL) n) / 16.0);
  
  fprintf(stderr, "Grid (" FMT_I "X" FMT_I "X" FMT_I ")\n", n, n, n);
  
  /* Potential parameters */
  lx = ((REAL) n) * step;
  /* Force constants for the harmonic potential */
  potential_params.kx = lx * 2.0;
  potential_params.ky = lx * 2.0;
  potential_params.kz = lx * 2.0;
  
  /* Initialize OpenMP threads */
  grid_threads_init(threads);
  
  /* allocate memory (mass = 1.0) */
  gwf = grid_wf_alloc(n, n, n, step, 1.0, WF_PERIODIC_BOUNDARY, 
                      WF_2ND_ORDER_PROPAGATOR, "WF");
  potential = cgrid_alloc(n, n, n, step, CGRID_PERIODIC_BOUNDARY, 0, "potential");
  workspace = cgrid_alloc(n, n, n, step, CGRID_PERIODIC_BOUNDARY, 0, "workspace");
  workspace2 = cgrid_alloc(n, n, n, step, CGRID_PERIODIC_BOUNDARY, 0, "workspace2");
#ifdef FOURTH_ORDER_PROPAGATOR
  sq_grad_pot = cgrid_alloc(n, n, n, step, CGRID_PERIODIC_BOUNDARY, 0, "sq_grad_pot");
#endif
  rworkspace = rgrid_alloc(n, n, n, step, RGRID_PERIODIC_BOUNDARY, 0, "rworkspace");
  
  /* Initialize wave function */
  grid_wf_map(gwf, wavepacket, &wp_params);
  grid_wf_normalize(gwf);
  
  /* Map potential */
  cgrid_smooth_map(potential, harmonic, &potential_params, 1);
  
  /* Propagate */
  time = time_step;
  for(l = 0; l < iterations; l++) {
    printf("Iteration " FMT_I " with wf norm = " FMT_R "\n", l, grid_wf_norm(gwf));
    /* Write |psi|^2 to output-* files */
    grid_wf_density(gwf, rworkspace);
    sprintf(fname, "output-" FMT_I, l);
    rgrid_write_grid(fname, rworkspace);
    /* Propagate one time step */
#ifdef FOURTH_ORDER_PROPAGATOR
    grid_wf_square_of_potential_gradient(sq_grad_pot,potential, workspace, workspace2);
    grid_wf_propagate(gwf, potential, sq_grad_pot, time, workspace);
#else
    grid_wf_propagate(gwf, potential, NULL, time, workspace);
#endif
  }

  /* Release resources */
  grid_wf_free(gwf);
  cgrid_free(workspace);
  cgrid_free(workspace2);
  rgrid_free(rworkspace);
  cgrid_free(potential);
  
  return 0;
}

/* Function for creating the initial wave packet */
REAL complex wavepacket(void *arg, REAL x, REAL y, REAL z) {

  REAL kx = ((wparams *) arg)->kx;
  REAL ky = ((wparams *) arg)->ky;
  REAL kz = ((wparams *) arg)->kz;
  REAL wx = ((wparams *) arg)->wx;
  REAL wy = ((wparams *) arg)->wy;
  REAL wz = ((wparams *) arg)->wz;
  REAL xc = ((wparams *) arg)->xc;
  REAL yc = ((wparams *) arg)->yc;
  REAL zc = ((wparams *) arg)->zc;
  REAL x2, y2, z2;

  x -= xc;
  y -= yc;
  z -= zc;
  x2 = x / wx; x2 *= x2;
  y2 = y / wy; y2 *= y2;
  z2 = z / wz; z2 *= z2;

  return CEXP(- x2 + I * kx * x - y2  + I * ky * y - z2 + I * kz * z);
}

/* Function for harmonic potential */
REAL complex harmonic(void *arg, REAL x, REAL y, REAL z) {

  pparams params = *((pparams *) arg);

  return 0.5 * (params.kx * params.kx * x * x + params.ky * params.ky * y * y 
                + params.kz * params.kz * z * z);
}
\end{verbatim}

\end{document}
